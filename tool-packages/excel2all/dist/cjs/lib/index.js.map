{"version":3,"file":"index.js","sources":["../../../src/default-value-func-map.ts","../../../src/get-os-eol.ts","../../../src/loger.ts","../../../src/table-utils.ts","../../../src/default-parse-handler.ts","../../../src/default-convert-hook.ts","../../../src/default-output-transformer.ts","../../../src/do-parse.ts","../../../src/file-utils.ts","../../../src/convert.ts"],"sourcesContent":["import { Logger } from \"./loger\";\n\nexport const valueTransFuncMap: {\n    [key: string]: ValueTransFunc;\n} = {};\nvalueTransFuncMap[\"int\"] = strToInt;\nvalueTransFuncMap[\"string\"] = anyToStr;\nvalueTransFuncMap[\"[int]\"] = strToIntArr;\nvalueTransFuncMap[\"[string]\"] = strToStrArr;\nvalueTransFuncMap[\"json\"] = strToJsonObj;\nfunction strToIntArr(fieldItem: ITableField, cellValue: string): ITransValueResult {\n    cellValue = (cellValue + \"\").replace(/，/g, \",\"); //为了防止策划误填，先进行转换\n    cellValue = cellValue.trim();\n    let intArr: number[];\n    const result: ITransValueResult = {};\n    if (cellValue !== \"\") {\n        try {\n            intArr = JSON.parse(cellValue);\n            result.value = intArr;\n        } catch (error) {\n            result.error = error;\n        }\n    }\n\n    return result;\n}\nfunction strToStrArr(fieldItem: ITableField, cellValue: string): ITransValueResult {\n    cellValue = (cellValue + \"\").replace(/，/g, \",\"); //为了防止策划误填，先进行转换\n    cellValue = cellValue.trim();\n    let result: ITransValueResult = {};\n    let arr: string[];\n    if (cellValue !== \"\") {\n        try {\n            arr = JSON.parse(cellValue);\n            result.value = arr;\n        } catch (error) {\n            result.error = error;\n        }\n    }\n    return result;\n}\nfunction strToInt(fieldItem: ITableField, cellValue: string): ITransValueResult {\n    let result: ITransValueResult = {} as any;\n    if (typeof cellValue === \"string\" && cellValue.trim() !== \"\") {\n        result.value = cellValue.includes(\".\") ? parseFloat(cellValue) : (parseInt(cellValue) as any);\n    } else if (typeof cellValue === \"number\") {\n        result.value = cellValue;\n    }\n    return result;\n}\nfunction strToJsonObj(fieldItem: ITableField, cellValue: string): ITransValueResult {\n    cellValue = (cellValue + \"\").replace(/，/g, \",\"); //为了防止策划误填，先进行转换\n    cellValue = cellValue.trim();\n    let obj;\n    let error;\n    if (cellValue !== \"\") {\n        try {\n            obj = JSON.parse(cellValue);\n        } catch (err) {\n            error = err;\n            obj = cellValue;\n        }\n    }\n    return { error: error, value: obj };\n}\nfunction anyToStr(fieldItem: ITableField, cellValue: any): ITransValueResult {\n    let result: ITransValueResult = {} as any;\n    if (typeof cellValue === \"string\") {\n        cellValue = cellValue.trim();\n        if (cellValue !== \"\") {\n            result.value = cellValue;\n        }\n    } else {\n        result.value = cellValue + \"\";\n    }\n    return result;\n}\n","import * as os from \"os\";\nconst platform = os.platform();\n/**当前系统行尾  platform === \"win32\" ? \"\\n\" : \"\\r\\n\";*/\nexport const osEol = platform === \"win32\" ? \"\\n\" : \"\\r\\n\";\n","import { osEol } from \"./get-os-eol\";\nimport * as path from \"path\";\nenum LogLevelEnum {\n    info,\n    warn,\n    error,\n    no\n}\nexport class Logger {\n    private static _enableOutPutLogFile: boolean;\n    private static _logLevel: LogLevelEnum;\n    private static _logStr: string = \"\";\n    /**\n     * 如果有输出过错误信息则为true\n     */\n    public static hasError: boolean = false;\n    public static init(convertConfig: ITableConvertConfig) {\n        const level: LogLevel = convertConfig.logLevel ? convertConfig.logLevel : \"info\";\n        this._logLevel = LogLevelEnum[level];\n        this._enableOutPutLogFile = convertConfig.outputLogDirPath === false ? false : true;\n    }\n    /**\n     * 输出日志,日志等级只是限制了控制台输出，但不限制日志记录\n     * @param message\n     * @param level\n     */\n    public static log(message: string, level: LogLevel = \"info\") {\n        if (level !== \"no\") {\n            if (this._logLevel <= LogLevelEnum[level]) {\n                switch (level) {\n                    case \"error\":\n                        console.error(message);\n                        if (!this.hasError) this.hasError = true;\n                        break;\n                    case \"info\":\n                        console.log(message);\n                        break;\n                    case \"warn\":\n                        console.warn(message);\n                        break;\n                }\n            }\n        }\n\n        if (!this._enableOutPutLogFile) return;\n        this._logStr += message + osEol;\n    }\n    /**\n     * 系统日志输出\n     * @param args\n     */\n    public static systemLog(message: string) {\n        console.log(message);\n        if (!this._enableOutPutLogFile) return;\n        this._logStr += message + osEol;\n    }\n    /**\n     * 返回日志数据并清空\n     */\n    public static get logStr(): string {\n        if (!this._enableOutPutLogFile) return null;\n        const logStr = this._logStr;\n        this._logStr = \"\"; //清空\n        return logStr;\n    }\n}\n","import * as xlsx from \"xlsx\";\n/**\n * 是否为空表格格子\n * @param cell\n */\nexport function isEmptyCell(cell: xlsx.CellObject) {\n    if (cell && cell.v !== undefined) {\n        if (typeof cell.v === \"string\") {\n            return cell.v === \"\";\n        } else if (typeof cell.v === \"number\") {\n            return isNaN(cell.v);\n        } else {\n            return false;\n        }\n    } else {\n        return true;\n    }\n}\n/**\n * 字母Z的编码\n */\nexport const ZCharCode = 90;\n/**\n * 字母A的编码\n *\n */\nexport const ACharCode = 65;\n/**\n * 根据当前列的charCodes获取下一列Key\n * @param charCodes\n */\nexport function getNextColKey(charCodes: number[]): string {\n    let isAdd: boolean;\n    for (let i = charCodes.length - 1; i >= 0; i--) {\n        if (charCodes[i] < ZCharCode) {\n            charCodes[i] += 1;\n            isAdd = true;\n            break;\n        } else if (charCodes[i] === ZCharCode) {\n            charCodes[i] = ACharCode;\n        }\n    }\n    if (!isAdd) {\n        charCodes.push(ACharCode);\n    }\n\n    return charCodesToString(charCodes);\n}\n\n/**\n * 列的字符编码数组转字符串\n * @param charCodes\n */\nexport function charCodesToString(charCodes: number[]): string {\n    return String.fromCharCode(...charCodes);\n}\n/**\n * 字符串转编码数组\n * @param colKey\n */\nexport function stringToCharCodes(colKey: string) {\n    const charCodes = [];\n    for (let i = 0; i < colKey.length; i++) {\n        charCodes.push(colKey.charCodeAt(i));\n    }\n    return charCodes;\n}\n/**\n * 纵向遍历表格\n * @param sheet xlsx表格对象\n * @param startRow 开始行 从1开始\n * @param startCol 列字符 比如A B\n * @param callback 遍历回调 (sheet: xlsx.Sheet, colKey: string, rowIndex: number) => void\n * @param isSheetRowEnd 是否行结束判断方法\n * @param isSheetColEnd 是否列结束判断方法\n * @param isSkipSheetRow 是否跳过行\n * @param isSkipSheetCol 是否跳过列\n */\nexport function verticalForEachSheet(\n    sheet: xlsx.Sheet,\n    startRow: number,\n    startCol: string,\n    callback: (sheet: xlsx.Sheet, colKey: string, rowIndex: number) => void,\n    isSheetRowEnd?: (sheet: xlsx.Sheet, rowIndex: number) => boolean,\n    isSheetColEnd?: (sheet: xlsx.Sheet, colkey: string) => boolean,\n    isSkipSheetRow?: (sheet: xlsx.Sheet, rowIndex: number) => boolean,\n    isSkipSheetCol?: (sheet: xlsx.Sheet, colKey: string) => boolean\n) {\n    const sheetRef: string = sheet[\"!ref\"];\n    const maxRowNum = parseInt(sheetRef.match(/\\d+$/)[0]);\n\n    const maxColKey = sheetRef.split(\":\")[1].match(/^[A-Za-z]+/)[0];\n    let maxColKeyCodeSum = getCharCodeSum(maxColKey);\n\n    let colCharCodes: number[];\n    let colKey: string;\n    let curColCodeSum: number = 0;\n    const startCharcodes = stringToCharCodes(startCol);\n    for (let i = startRow; i <= maxRowNum; i++) {\n        if (isSheetRowEnd ? isSheetRowEnd(sheet, i) : false) break;\n        if (isSkipSheetRow ? isSkipSheetRow(sheet, i) : false) continue;\n        colCharCodes = startCharcodes.concat([]);\n\n        colKey = startCol;\n\n        let hasNextCol = isSheetColEnd ? !isSheetColEnd(sheet, colKey) : true;\n        while (hasNextCol) {\n            if (!(isSkipSheetCol ? isSkipSheetCol(sheet, colKey) : false)) {\n                callback(sheet, colKey, i);\n            }\n            colKey = getNextColKey(colCharCodes);\n            curColCodeSum = getCharCodeSum(colKey);\n            if (maxColKeyCodeSum >= curColCodeSum) {\n                hasNextCol = isSheetColEnd ? !isSheetColEnd(sheet, colKey) : true;\n            } else {\n                hasNextCol = false;\n            }\n        }\n    }\n}\n\n/**\n * 横向遍历表格\n * @param sheet xlsx表格对象\n * @param startRow 开始行 从1开始\n * @param startCol 列字符 比如A B\n * @param callback 遍历回调 (sheet: xlsx.Sheet, colKey: string, rowIndex: number) => void\n * @param isSheetRowEnd 是否行结束判断方法\n * @param isSheetColEnd 是否列结束判断方法\n * @param isSkipSheetRow 是否跳过行\n * @param isSkipSheetCol 是否跳过列\n */\nexport function horizontalForEachSheet(\n    sheet: xlsx.Sheet,\n    startRow: number,\n    startCol: string,\n    callback: (sheet: xlsx.Sheet, colKey: string, rowIndex: number) => void,\n    isSheetRowEnd?: (sheet: xlsx.Sheet, rowIndex: number) => boolean,\n    isSheetColEnd?: (sheet: xlsx.Sheet, colkey: string) => boolean,\n    isSkipSheetRow?: (sheet: xlsx.Sheet, rowIndex: number) => boolean,\n    isSkipSheetCol?: (sheet: xlsx.Sheet, colKey: string) => boolean\n) {\n    const sheetRef: string = sheet[\"!ref\"];\n    const maxRowNum = parseInt(sheetRef.match(/\\d+$/)[0]);\n\n    const maxColKey = sheetRef.split(\":\")[1].match(/^[A-Za-z]+/)[0];\n    const maxColKeyCodeSum = getCharCodeSum(maxColKey);\n    let colCharCodes: number[];\n    let colKey: string;\n    colCharCodes = stringToCharCodes(startCol);\n    let curColCodeSum: number = 0;\n    colKey = startCol;\n    let hasNextCol = isSheetColEnd ? !isSheetColEnd(sheet, colKey) : true;\n    while (hasNextCol) {\n        if (!(isSkipSheetCol ? isSkipSheetCol(sheet, colKey) : false)) {\n            for (let i = startRow; i <= maxRowNum; i++) {\n                if (isSheetRowEnd ? isSheetRowEnd(sheet, i) : false) break;\n                if (isSkipSheetRow ? isSkipSheetRow(sheet, i) : false) continue;\n                callback(sheet, colKey, i);\n            }\n        }\n\n        colKey = getNextColKey(colCharCodes);\n        curColCodeSum = getCharCodeSum(colKey);\n        if (maxColKeyCodeSum >= curColCodeSum) {\n            hasNextCol = isSheetColEnd ? !isSheetColEnd(sheet, colKey) : true;\n        } else {\n            hasNextCol = false;\n        }\n    }\n}\nlet colKeySumMap = {};\nfunction getCharCodeSum(colKey: string): number {\n    let sum: number = colKeySumMap[colKey];\n    if (!sum) {\n        sum = 0;\n        for (let i = 0; i < colKey.length; i++) {\n            sum += colKey.charCodeAt(i);\n        }\n        colKeySumMap[colKey] = sum;\n    }\n    return sum;\n}\n/**\n * 读取配置表文件 同步的\n * @param fileInfo\n */\nexport function readTableFile(fileInfo: IFileInfo): xlsx.WorkBook {\n    const workBook = xlsx.readFile(fileInfo.filePath, { type: isCSV(fileInfo.fileExtName) ? \"string\" : \"file\" });\n    return workBook;\n}\n/**\n * 根据文件名后缀判断是否为csv文件\n * @param fileExtName\n */\nexport function isCSV(fileExtName: string): boolean {\n    return fileExtName === \"csv\";\n}\n","import * as xlsx from \"xlsx\";\nimport { valueTransFuncMap } from \"./default-value-func-map\";\nimport { Logger } from \"./loger\";\nimport { horizontalForEachSheet, isEmptyCell, readTableFile, verticalForEachSheet } from \"./table-utils\";\n\ndeclare global {\n    interface ITableField {\n        /**配置表中注释值 */\n        text: string;\n        /**配置表中类型值 */\n        originType: string;\n        /**配置表中字段名值 */\n        originFieldName: string;\n        /**解析后的类型值 */\n        type?: string;\n        /**解析后的字段名值 */\n        fieldName?: string;\n        /**对象的子字段名 */\n        subFieldName?: string;\n        /**多列对象 */\n        isMutiColObj?: boolean;\n    }\n    interface ITableDefine {\n        /**配置表名 */\n        tableName: string;\n        /**配置表类型 默认两种: vertical 和 horizontal*/\n        tableType: string;\n\n        /**开始行从1开始 */\n        startRow: number;\n        /**开始列从A开始 */\n        startCol: string;\n        /**垂直解析字段定义 */\n        verticalFieldDefine: IVerticalFieldDefine;\n        /**横向解析字段定义 */\n        horizontalFieldDefine: IHorizontalFieldDefine;\n    }\n    interface IHorizontalFieldDefine {\n        /**类型行 */\n        typeCol: string;\n        /**字段名行 */\n        fieldCol: string;\n        /**注释行 */\n        textCol: string;\n    }\n    interface IVerticalFieldDefine {\n        /**类型行 */\n        typeRow: number;\n        /**字段名行 */\n        fieldRow: number;\n        /**注释行 */\n        textRow: number;\n    }\n    /**\n     * 字段字典\n     * key是列colKey\n     * value是字段对象\n     */\n    type ColKeyTableFieldMap = { [key: string]: ITableField };\n\n    /**\n     * 表格的一行或者一列\n     * key为字段名值，value为表格的一格\n     */\n    type TableRowOrCol = { [key: string]: ITableCell };\n    /**\n     * 表格的一格\n     */\n    interface ITableCell {\n        /**字段对象 */\n        filed: ITableField;\n        /**值 */\n        value: any;\n    }\n    /**\n     * 表格行或列的字典\n     * key为行索引，value为表格的一行\n     */\n    type TableRowOrColMap = { [key: string]: TableRowOrCol };\n    /**\n     * 表格行或列值数组\n     * key主键，value是值数组\n     */\n    type RowOrColValuesMap = { [key: string]: any[] };\n    interface ITableValues {\n        /**字段名数组 */\n        fields: string[];\n        /**表格值数组 */\n        rowOrColValuesMap: RowOrColValuesMap;\n    }\n    /**\n     * 解析结果\n     */\n    interface ITableParseResult {\n        /**配置表定义 */\n        tableDefine?: ITableDefine;\n        /**当前分表名 */\n        curSheetName?: string;\n        /**字段字典 */\n        filedMap?: ColKeyTableFieldMap;\n        // /**表格行或列的字典 */\n        // rowOrColMap: TableRowOrColMap\n        /**单个表格对象 */\n        /**key是主键值，value是一行对象 */\n        tableObj?: { [key: string]: any };\n        /**当前行或列对象 */\n        curRowOrColObj?: any;\n        /**主键值 */\n        mainKeyFieldName?: string;\n    }\n\n    /**值转换方法 */\n    interface ITransValueResult {\n        error?: any;\n        value?: any;\n    }\n    type ValueTransFunc = (fieldItem: ITableField, cellValue: any) => ITransValueResult;\n    /**\n     * 值转换方法字典\n     * key是类型key\n     * value是方法\n     */\n    type ValueTransFuncMap = { [key: string]: ValueTransFunc };\n}\nexport enum TableType {\n    vertical = \"vertical\",\n    horizontal = \"horizontal\"\n}\n\nexport class DefaultParseHandler implements ITableParseHandler {\n    private _valueTransFuncMap: ValueTransFuncMap;\n    constructor() {\n        this._valueTransFuncMap = valueTransFuncMap;\n    }\n    getTableDefine(fileInfo: IFileInfo, workBook: xlsx.WorkBook): ITableDefine {\n        //取表格文件名为表格名\n        const tableName = fileInfo.fileName;\n\n        const tableDefine: Partial<ITableDefine> = {\n            tableName: tableName\n        };\n\n        let cellKey: string;\n        let cellObj: xlsx.CellObject;\n        //取第一个表\n        const sheetNames = workBook.SheetNames;\n        let sheet: xlsx.Sheet;\n        let firstCellValue: { tableNameInSheet: string; tableType: string };\n        let firstCellObj: xlsx.CellObject;\n        for (let i = 0; i < sheetNames.length; i++) {\n            sheet = workBook.Sheets[sheetNames[i]];\n            firstCellObj = sheet[\"A\" + 1];\n            if (!isEmptyCell(firstCellObj)) {\n                firstCellValue = this._getFirstCellValue(firstCellObj);\n                if (firstCellValue && firstCellValue.tableNameInSheet === tableName) {\n                    break;\n                }\n            }\n        }\n        if (!firstCellValue || firstCellValue.tableNameInSheet !== tableName) {\n            Logger.log(`表格不规范,跳过解析,路径:${fileInfo.filePath}`, \"error\");\n            return null;\n        }\n        tableDefine.tableType = firstCellValue.tableType;\n        if (tableDefine.tableType === TableType.vertical) {\n            tableDefine.verticalFieldDefine = {} as any;\n            const verticalFieldDefine: IVerticalFieldDefine = tableDefine.verticalFieldDefine;\n            verticalFieldDefine.textRow = 1;\n            for (let i = 1; i < 100; i++) {\n                cellKey = \"A\" + i;\n                cellObj = sheet[cellKey];\n                if (isEmptyCell(cellObj) || cellObj.v === \"NO\" || cellObj.v === \"END\" || cellObj.v === \"START\") {\n                    tableDefine.startRow = i;\n                } else if (cellObj.v === \"CLIENT\") {\n                    verticalFieldDefine.fieldRow = i;\n                } else if (cellObj.v === \"TYPE\") {\n                    verticalFieldDefine.typeRow = i;\n                }\n                if (tableDefine.startRow && verticalFieldDefine.fieldRow && verticalFieldDefine.typeRow) break;\n            }\n\n            tableDefine.startCol = \"B\";\n        } else if (tableDefine.tableType === TableType.horizontal) {\n            tableDefine.horizontalFieldDefine = {} as any;\n            const horizontalFieldDefine = tableDefine.horizontalFieldDefine;\n            horizontalFieldDefine.textCol = \"A\";\n            horizontalFieldDefine.typeCol = \"B\";\n            horizontalFieldDefine.fieldCol = \"C\";\n            tableDefine.startCol = \"E\";\n            tableDefine.startRow = 2;\n        }\n\n        return tableDefine as any;\n    }\n    private _getFirstCellValue(firstCellObj: xlsx.CellObject) {\n        if (!firstCellObj) return;\n        const cellValues = (firstCellObj.v as string).split(\":\");\n        let tableNameInSheet: string;\n        let tableType: string;\n        if (cellValues.length > 1) {\n            tableNameInSheet = cellValues[1];\n            tableType = cellValues[0] === \"H\" ? TableType.horizontal : TableType.vertical;\n        } else {\n            tableNameInSheet = cellValues[0];\n            tableType = TableType.vertical;\n        }\n        return { tableNameInSheet: tableNameInSheet, tableType: tableType };\n    }\n    /**\n     * 判断表格是否能解析\n     * @param sheet\n     */\n    checkSheetCanParse(tableDefine: ITableDefine, sheet: xlsx.Sheet, sheetName: string): boolean {\n        //如果这个表个第一格值不等于表名，则不解析\n        const firstCellObj: xlsx.CellObject = sheet[\"A\" + 1];\n        const firstCellValue = this._getFirstCellValue(firstCellObj);\n        if (firstCellObj && tableDefine) {\n            if (firstCellValue.tableNameInSheet !== tableDefine.tableName) {\n                return false;\n            }\n            return true;\n        } else {\n            return false;\n        }\n    }\n    /**\n     * 表行结束判断\n     * @param tableDefine\n     * @param sheet\n     * @param row\n     */\n    isSheetRowEnd(tableDefine: ITableDefine, sheet: xlsx.Sheet, row: number): boolean {\n        // if (tableDefine.tableType === TableType.vertical) {\n\n        // } else if (tableDefine.tableType === TableType.horizontal) {\n\n        // }\n        //判断上一行的标志是否为END\n        if (row > 1) {\n            row = row - 1;\n            const cellObj: xlsx.CellObject = sheet[\"A\" + row];\n            return cellObj && cellObj.v === \"END\";\n        } else {\n            return false;\n        }\n    }\n    /**\n     * 表列结束判断\n     * @param tableDefine\n     * @param sheet\n     * @param colKey\n     */\n    isSheetColEnd(tableDefine: ITableDefine, sheet: xlsx.Sheet, colKey: string): boolean {\n        //判断这一列第一行是否为空\n        const firstCellObj: xlsx.CellObject = sheet[colKey + 1];\n        // const typeCellObj: xlsx.CellObject = sheet[colKey + tableFile.tableDefine.typeRow];\n        return isEmptyCell(firstCellObj);\n    }\n    /**\n     * 检查行是否需要解析\n     * @param tableDefine\n     * @param sheet\n     * @param rowIndex\n     */\n    checkRowNeedParse(tableDefine: ITableDefine, sheet: xlsx.Sheet, rowIndex: number): boolean {\n        const cellObj: xlsx.CellObject = sheet[\"A\" + rowIndex];\n        if (cellObj && cellObj.v === \"NO\") {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * 解析单个格子\n     * @param tableParseResult\n     * @param sheet\n     * @param colKey\n     * @param rowIndex\n     * @param isNewRowOrCol 是否为新的一行或者一列\n     */\n    parseVerticalCell(\n        tableParseResult: ITableParseResult,\n        sheet: xlsx.Sheet,\n        colKey: string,\n        rowIndex: number,\n        isNewRowOrCol: boolean\n    ): void {\n        const fieldInfo = this.getVerticalTableField(tableParseResult, sheet, colKey, rowIndex);\n        if (!fieldInfo) return;\n        const cell: xlsx.CellObject = sheet[colKey + rowIndex];\n        if (isEmptyCell(cell)) {\n            return;\n        }\n\n        const transResult = this.transValue(tableParseResult, fieldInfo, cell.v);\n        if (transResult.error) {\n            Logger.log(\n                `!!!!!!!!!!!!!!!!!![-----解析错误-----]!!!!!!!!!!!!!!!!!!!!!!!!!\\n` +\n                    `[sheetName|分表名]=> ${tableParseResult.curSheetName}\\n` +\n                    `[row|行]=> ${rowIndex}\\n` +\n                    `[col|列]=> ${colKey}\\n` +\n                    `[field|字段]=> ${fieldInfo.originFieldName}\\n` +\n                    `[type|类型]=> ${fieldInfo.originType}\\n` +\n                    `[error|错误]=> ${\n                        typeof transResult.error === \"string\" ? transResult.error : transResult.error.message\n                    }\\n`,\n                \"error\"\n            );\n            // Logger.log(transResult.error, \"error\");\n        }\n        const transedValue = transResult.value;\n        let mainKeyFieldName: string = tableParseResult.mainKeyFieldName;\n        if (!mainKeyFieldName) {\n            //第一个字段就是主键\n            mainKeyFieldName = fieldInfo.fieldName;\n            tableParseResult.mainKeyFieldName = fieldInfo.fieldName;\n            tableParseResult.tableObj = {};\n        }\n        let rowOrColObj: any = tableParseResult.curRowOrColObj;\n        if (isNewRowOrCol) {\n            //新的一行\n            rowOrColObj = {};\n            tableParseResult.curRowOrColObj = tableParseResult.tableObj[transedValue] = rowOrColObj;\n        }\n\n        if (fieldInfo.isMutiColObj) {\n            let subObj = rowOrColObj[fieldInfo.fieldName];\n            if (!subObj) {\n                subObj = {};\n                rowOrColObj[fieldInfo.fieldName] = subObj;\n            }\n            subObj[fieldInfo.subFieldName] = transedValue;\n        } else {\n            rowOrColObj[fieldInfo.fieldName] = transedValue;\n        }\n    }\n    /**\n     * 解析横向单个格子\n     * @param tableParseResult\n     * @param sheet\n     * @param colKey\n     * @param rowIndex\n     * @param isNewRowOrCol 是否为新的一行或者一列\n     */\n    parseHorizontalCell(\n        tableParseResult: ITableParseResult,\n        sheet: xlsx.Sheet,\n        colKey: string,\n        rowIndex: number,\n        isNewRowOrCol: boolean\n    ): void {\n        const fieldInfo = this.getHorizontalTableField(tableParseResult, sheet, colKey, rowIndex);\n        if (!fieldInfo) return;\n        const cell: xlsx.CellObject = sheet[colKey + rowIndex];\n        if (isEmptyCell(cell)) {\n            return;\n        }\n        const transResult = this.transValue(tableParseResult, fieldInfo, cell.v);\n        if (transResult.error) {\n            Logger.log(\n                `!!!!!!!!!!!!!!!!!![-----ParseError|解析错误-----]!!!!!!!!!!!!!!!!!!!!!!!!!\\n` +\n                    `[sheetName|分表名]=> ${tableParseResult.curSheetName}\\n` +\n                    `[row|行]=> ${rowIndex}\\n` +\n                    `[col|列]=> ${colKey}\\n` +\n                    `[field|字段]=> ${fieldInfo.originFieldName}\\n` +\n                    `[type|类型]=> ${fieldInfo.originType}\\n` +\n                    `[error|错误]=> ${\n                        typeof transResult.error === \"string\" ? transResult.error : transResult.error.message\n                    }\\n`+\n                `!!!!!!!!!!!!!!!!!![-----ParseError|解析错误-----]!!!!!!!!!!!!!!!!!!!!!!!!!\\n`,\n                \n                \"error\"\n            );\n        }\n        const transedValue = transResult.value;\n        if (!tableParseResult.tableObj) {\n            tableParseResult.tableObj = {};\n        }\n        if (fieldInfo.isMutiColObj) {\n            let subObj = tableParseResult.tableObj[fieldInfo.fieldName];\n            if (!subObj) {\n                subObj = {};\n                tableParseResult.tableObj[fieldInfo.fieldName] = subObj;\n            }\n            subObj[fieldInfo.subFieldName] = transedValue;\n        } else {\n            tableParseResult.tableObj[fieldInfo.fieldName] = transedValue;\n        }\n    }\n    /**\n     * 解析出字段对象\n     * @param tableParseResult\n     * @param sheet\n     * @param colKey\n     * @param rowIndex\n     */\n    getVerticalTableField(\n        tableParseResult: ITableParseResult,\n        sheet: xlsx.Sheet,\n        colKey: string,\n        rowIndex: number\n    ): ITableField {\n        const tableDefine = tableParseResult.tableDefine;\n        let tableFiledMap = tableParseResult.filedMap;\n        if (!tableFiledMap) {\n            tableFiledMap = {};\n            tableParseResult.filedMap = tableFiledMap;\n        }\n        const verticalFieldDefine = tableDefine.verticalFieldDefine;\n        const filedCell = sheet[colKey + verticalFieldDefine.fieldRow];\n        let originFieldName: string;\n        if (!isEmptyCell(filedCell)) {\n            originFieldName = filedCell.v as string;\n        }\n        if (!originFieldName) return null;\n        let field: ITableField = {} as any;\n        //缓存\n        if (tableFiledMap[originFieldName] !== undefined) {\n            return tableFiledMap[originFieldName];\n        }\n        //注释\n        const textCell: xlsx.CellObject = sheet[colKey + verticalFieldDefine.textRow];\n        if (!isEmptyCell(textCell)) {\n            field.text = textCell.v as string;\n        }\n        //类型\n        let isObjType: boolean = false;\n        const typeCell = sheet[colKey + verticalFieldDefine.typeRow];\n\n        if (isEmptyCell(typeCell)) {\n            return null;\n        } else {\n            field.originType = typeCell.v as string;\n            if (field.originType.includes(\"mf:\")) {\n                const typeStrs = field.originType.split(\":\");\n                if (typeStrs.length < 3) {\n                    return null;\n                }\n                field.type = typeStrs[2];\n                isObjType = true;\n            } else {\n                field.type = field.originType;\n            }\n        }\n        field.isMutiColObj = isObjType;\n        //字段名\n        field.originFieldName = originFieldName;\n        if (isObjType) {\n            const fieldStrs = field.originFieldName.split(\":\");\n            if (fieldStrs.length < 2) {\n                return null;\n            }\n            field.fieldName = fieldStrs[0];\n            field.subFieldName = fieldStrs[1];\n        } else {\n            field.fieldName = field.originFieldName;\n        }\n\n        tableFiledMap[colKey] = field;\n        return field;\n    }\n    getHorizontalTableField(\n        tableParseResult: ITableParseResult,\n        sheet: xlsx.Sheet,\n        colKey: string,\n        rowIndex: number\n    ): ITableField {\n        const tableDefine = tableParseResult.tableDefine;\n        let tableFiledMap = tableParseResult.filedMap;\n        if (!tableFiledMap) {\n            tableFiledMap = {};\n            tableParseResult.filedMap = tableFiledMap;\n        }\n        const hFieldDefine = tableDefine.horizontalFieldDefine;\n        const fieldNameCell: xlsx.CellObject = sheet[hFieldDefine.fieldCol + rowIndex];\n        let originFieldName: string;\n        if (!isEmptyCell(fieldNameCell)) {\n            originFieldName = fieldNameCell.v as string;\n        }\n        if (!originFieldName) return null;\n        if (tableFiledMap[originFieldName] !== undefined) {\n            return tableFiledMap[originFieldName];\n        }\n        let field: ITableField = {} as any;\n\n        const textCell: xlsx.CellObject = sheet[hFieldDefine.textCol + rowIndex];\n        //注释\n        if (!isEmptyCell(textCell)) {\n            field.text = textCell.v as string;\n        }\n        let isObjType: boolean = false;\n        //类型\n        const typeCell: xlsx.CellObject = sheet[hFieldDefine.typeCol + rowIndex];\n\n        if (isEmptyCell(typeCell)) {\n            return null;\n        } else {\n            //处理类型\n            field.originType = typeCell.v as string;\n            if (field.originType.includes(\"mf:\")) {\n                const typeStrs = field.originType.split(\":\");\n                if (typeStrs.length < 3) {\n                    return null;\n                }\n                field.type = typeStrs[2];\n                isObjType = true;\n            } else {\n                field.type = field.originType;\n            }\n        }\n        field.isMutiColObj = isObjType;\n        field.originFieldName = originFieldName;\n        if (isObjType) {\n            const fieldStrs = field.originFieldName.split(\":\");\n            if (fieldStrs.length < 2) {\n                return null;\n            }\n            field.fieldName = fieldStrs[0];\n            field.subFieldName = fieldStrs[1];\n        } else {\n            field.fieldName = field.originFieldName;\n        }\n        tableFiledMap[originFieldName] = field;\n        return field;\n    }\n    /**\n     * 检查列是否需要解析\n     * @param tableDefine\n     * @param sheet\n     * @param colKey\n     */\n    checkColNeedParse(tableDefine: ITableDefine, sheet: xlsx.Sheet, colKey: string): boolean {\n        // 如果类型或者则不需要解析\n        if (tableDefine.tableType === TableType.vertical) {\n            const verticalFieldDefine = tableDefine.verticalFieldDefine;\n            const typeCellObj: xlsx.CellObject = sheet[colKey + verticalFieldDefine.typeRow];\n            const fieldCellObj: xlsx.CellObject = sheet[colKey + verticalFieldDefine.fieldRow];\n            if (isEmptyCell(typeCellObj) || isEmptyCell(fieldCellObj)) {\n                return false;\n            } else {\n                return true;\n            }\n        } else if (tableDefine.tableType === TableType.horizontal) {\n            const cellObj: xlsx.CellObject = sheet[colKey + 1];\n            if (isEmptyCell(cellObj)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n    }\n    /**\n     * 转换表格的值\n     * @param parseResult\n     * @param filedItem\n     * @param cellValue\n     */\n    public transValue(parseResult: ITableParseResult, filedItem: ITableField, cellValue: any): ITransValueResult {\n        let transResult: ITransValueResult;\n\n        let transFunc = this._valueTransFuncMap[filedItem.type];\n        if (!transFunc) {\n            transFunc = this._valueTransFuncMap[\"json\"];\n        }\n        transResult = transFunc(filedItem, cellValue);\n        return transResult;\n    }\n\n    /**\n     * 解析配置表文件\n     * @param parseConfig 解析配置\n     * @param fileInfo 文件信息\n     * @param parseResult 解析结果\n     */\n    public parseTableFile(\n        parseConfig: ITableConvertConfig,\n        fileInfo: IFileInfo,\n        parseResult: ITableParseResult\n    ): ITableParseResult {\n        const workbook = readTableFile(fileInfo);\n        if (!workbook.SheetNames.length) return;\n\n        const sheetNames = workbook.SheetNames;\n        const tableDefine: ITableDefine = this.getTableDefine(fileInfo, workbook);\n        for (let i = 0; i < sheetNames.length; i++) {}\n        if (!tableDefine) return null;\n        let sheetName: string;\n        let sheet: xlsx.Sheet;\n        const isSheetRowEnd = this.isSheetRowEnd.bind(null, tableDefine);\n        const isSheetColEnd = this.isSheetColEnd.bind(null, tableDefine);\n        const isSkipSheetRow = (sheet: xlsx.Sheet, rowIndex: number) => {\n            return !this.checkRowNeedParse(tableDefine, sheet, rowIndex);\n        };\n        const isSkipSheetCol = (sheet: xlsx.Sheet, colKey: string) => {\n            return !this.checkColNeedParse(tableDefine, sheet, colKey);\n        };\n        let cellObj: xlsx.CellObject;\n        parseResult.tableDefine = tableDefine;\n        Logger.log(`[parseTable|解析文件]=> ${fileInfo.filePath}`);\n        for (let i = 0; i < sheetNames.length; i++) {\n            sheetName = sheetNames[i];\n            sheet = workbook.Sheets[sheetName];\n            if (!this.checkSheetCanParse(tableDefine, sheet, sheetName)) {\n                continue;\n            }\n            parseResult.curSheetName = sheetName;\n            Logger.log(`|=[parseSheet|解析分表]=> ${sheetName}`);\n            if (tableDefine.tableType === TableType.vertical) {\n                let lastRowIndex: number;\n\n                verticalForEachSheet(\n                    sheet,\n                    tableDefine.startRow,\n                    tableDefine.startCol,\n                    (sheet, colKey: string, rowIndex: number) => {\n                        let isNewRowOrCol = false;\n                        if (lastRowIndex !== rowIndex) {\n                            lastRowIndex = rowIndex;\n                            isNewRowOrCol = true;\n                        }\n                        cellObj = sheet[colKey + rowIndex];\n                        if (!isEmptyCell(cellObj)) {\n                            this.parseVerticalCell(parseResult, sheet, colKey, rowIndex, isNewRowOrCol);\n                        }\n                    },\n                    isSheetRowEnd,\n                    isSheetColEnd,\n                    isSkipSheetRow,\n                    isSkipSheetCol\n                );\n            } else if (tableDefine.tableType === TableType.horizontal) {\n                let lastColKey: string;\n\n                horizontalForEachSheet(\n                    sheet,\n                    tableDefine.startRow,\n                    tableDefine.startCol,\n                    (sheet, colKey: string, rowIndex: number) => {\n                        let isNewRowOrCol = false;\n                        if (lastColKey !== colKey) {\n                            lastColKey = colKey;\n                            isNewRowOrCol = true;\n                        }\n\n                        cellObj = sheet[colKey + rowIndex];\n                        if (!isEmptyCell(cellObj)) {\n                            this.parseHorizontalCell(parseResult, sheet, colKey, rowIndex, isNewRowOrCol);\n                        }\n                    },\n                    isSheetRowEnd,\n                    isSheetColEnd,\n                    isSkipSheetRow,\n                    isSkipSheetCol\n                );\n            }\n        }\n\n        return parseResult as any;\n    }\n}\n","import { DefaultOutPutTransformer } from \"./default-output-transformer\";\nimport { Logger } from \"./loger\";\n\nexport class DefaultConvertHook implements IConvertHook {\n    onStart?(context: IConvertContext, cb: VoidFunction): void {\n        Logger.systemLog(`convert-hook onStart`);\n        cb();\n    }\n    onParseBefore?(context: IConvertContext, cb: VoidFunction): void {\n        Logger.systemLog(`convert-hook onParseBefore`);\n        cb();\n    }\n    onParseAfter?(context: IConvertContext, cb: VoidFunction): void {\n        let transformer: IOutPutTransformer = context.outputTransformer;\n\n        transformer.transform(context, cb);\n    }\n    onWriteFileEnd(context: IConvertContext): void {\n        Logger.systemLog(`convert-hook onWriteFileEnd 写入结束`);\n    }\n}\n","import * as path from \"path\";\nimport { TableType } from \"./default-parse-handler\";\nimport { deflateSync } from \"zlib\";\nimport { osEol } from \"./get-os-eol\";\ndeclare global {\n    /**\n     * 输出配置\n     */\n    interface IOutputConfig {\n        /**单个配置表json输出目录路径 */\n        clientSingleTableJsonDir?: string;\n        /**合并配置表json文件路径(包含文件名,比如 ./out/bundle.json) */\n        clientBundleJsonOutPath?: string;\n        /**是否格式化合并后的json，默认不 */\n        isFormatBundleJson?: boolean;\n        /**是否生成声明文件，默认不输出 */\n        isGenDts?: boolean;\n        /**声明文件输出目录(每个配置表一个声明)，默认不输出 */\n        clientDtsOutDir?: string;\n        /**是否合并所有声明为一个文件,默认true */\n        isBundleDts?: boolean;\n        /**合并后的声明文件名,如果没有则默认为tableMap */\n        bundleDtsFileName?: string;\n        /**是否将json格式压缩,默认否,减少json字段名字符,效果较小 */\n        isCompress?: boolean;\n        /**是否Zip压缩,使用zlib */\n        isZip?: boolean;\n    }\n}\n\n/**类型字符串映射字典 */\nconst typeStrMap = { int: \"number\", json: \"any\", \"[int]\": \"number[]\", \"[string]\": \"string[]\" };\nexport class DefaultOutPutTransformer {\n    /**\n     * 转换\n     * @param context\n     * @returns\n     */\n    transform(context: IConvertContext, cb: VoidFunction) {\n        const convertConfig = context.convertConfig;\n        const parseResultMap = context.parseResultMap;\n        let outputConfig: IOutputConfig = convertConfig.outputConfig;\n        if (!outputConfig) {\n            console.error(`parseConfig.outputConfig is undefind`);\n            return;\n        }\n\n        let tableObjMap: { [key: string]: any } = {};\n        let outputFileMap: OutPutFileMap = {};\n        let tableTypeMapDtsStr = \"\";\n        let tableTypeDtsStrs = \"\";\n        let parseResult: ITableParseResult;\n        let tableName: string;\n        let tableObj: any;\n        let objTypeTableMap: { [key: string]: boolean } = {};\n        for (let filePath in parseResultMap) {\n            parseResult = parseResultMap[filePath];\n            if (!parseResult.tableDefine) continue;\n\n            tableName = parseResult.tableDefine.tableName;\n\n            //合并多个同名表\n            tableObj = tableObjMap[tableName];\n            if (tableObj) {\n                tableObj = Object.assign(tableObj, parseResult.tableObj);\n            } else {\n                tableObj = parseResult.tableObj;\n            }\n            tableObjMap[tableName] = tableObj;\n\n            if (outputConfig.isGenDts && objTypeTableMap[tableName] === undefined) {\n                objTypeTableMap[tableName] = parseResult.tableDefine.tableType === TableType.horizontal;\n                if (parseResult.tableDefine.tableType === TableType.horizontal) {\n                    tableTypeMapDtsStr += \"\\treadonly \" + tableName + \"?: \" + `IT_${tableName};` + osEol;\n                } else {\n                    tableTypeMapDtsStr += this._getOneTableTypeStr(tableName);\n                }\n                //输出单个文件\n                if (outputConfig.isBundleDts === undefined) outputConfig.isBundleDts = true;\n                if (!outputConfig.isBundleDts) {\n                    this._addSingleTableDtsOutputFile(outputConfig, parseResult, outputFileMap);\n                } else {\n                    tableTypeDtsStrs += this._getSingleTableDts(parseResult);\n                }\n            }\n\n            //生成单个表json\n            if (outputConfig.clientSingleTableJsonDir) {\n                this._addSingleTableJsonOutputFile(outputConfig, parseResult, outputFileMap);\n            }\n        }\n        if (outputConfig.isGenDts) {\n            //输出声明文件\n            let itBaseStr = \"interface ITBase<T> { [key:string]:T}\" + osEol;\n\n            tableTypeMapDtsStr = itBaseStr + \"interface IT_TableMap {\" + osEol + tableTypeMapDtsStr + \"}\" + osEol;\n\n            if (outputConfig.isBundleDts) {\n                //合成一个文件\n                const dtsFileName = outputConfig.bundleDtsFileName ? outputConfig.bundleDtsFileName : \"tableMap\";\n                const bundleDtsFilePath = path.join(outputConfig.clientDtsOutDir, `${dtsFileName}.d.ts`);\n                outputFileMap[bundleDtsFilePath] = {\n                    filePath: bundleDtsFilePath,\n                    data: tableTypeMapDtsStr + tableTypeDtsStrs\n                };\n            } else {\n                //拆分文件输出\n                const tableTypeMapDtsFilePath = path.join(outputConfig.clientDtsOutDir, \"tableMap.d.ts\");\n                outputFileMap[tableTypeMapDtsFilePath] = {\n                    filePath: tableTypeMapDtsFilePath,\n                    data: tableTypeMapDtsStr\n                };\n            }\n        }\n\n        //jsonBundleFile\n        if (outputConfig.clientBundleJsonOutPath) {\n            let jsonBundleFilePath = outputConfig.clientBundleJsonOutPath;\n            let outputData: any;\n            if (outputConfig.isCompress) {\n                //进行格式压缩\n                const newTableObjMap = {};\n                let tableObj: any;\n                let newTableObj: any;\n                for (let tableName in tableObjMap) {\n                    if (objTypeTableMap[tableName]) {\n                        newTableObjMap[tableName] = tableObjMap[tableName];\n                        continue;\n                    }\n                    tableObj = tableObjMap[tableName];\n                    newTableObj = { fieldValuesMap: {} };\n                    for (let mainKey in tableObj) {\n                        if (!newTableObj.fieldNames) {\n                            newTableObj.fieldNames = Object.keys(tableObj[mainKey]);\n                        }\n                        newTableObj.fieldValuesMap[mainKey] = Object.values(tableObj[mainKey]);\n                    }\n                    newTableObjMap[tableName] = newTableObj;\n                }\n                outputData = JSON.stringify(newTableObjMap);\n            } else {\n                outputData = JSON.stringify(tableObjMap);\n            }\n            //进行base64处理\n            // if (outputConfig.bundleJsonIsEncode2Base64) {\n            //     outputData = Base64.encode(outputData);\n            //     if (outputConfig.preBase64UglyString) {\n            //         outputData = outputConfig.preBase64UglyString + outputData;\n            //     }\n            //     if (outputConfig.sufBase64UglyString) {\n            //         outputData += outputConfig.sufBase64UglyString;\n            //     }\n            // }\n            if (outputConfig.isZip) {\n                //使用zilb压缩\n                outputData = deflateSync(outputData);\n            }\n            outputFileMap[jsonBundleFilePath] = {\n                filePath: jsonBundleFilePath,\n                encoding: typeof outputData !== \"string\" ? \"binary\" : \"utf-8\",\n                data: outputData\n            };\n        }\n        if (context.outPutFileMap) {\n            for (let key in outputFileMap) {\n                context.outPutFileMap[key] = outputFileMap[key];\n            }\n        } else {\n            context.outPutFileMap = outputFileMap;\n        }\n        cb();\n    }\n    private _addSingleTableDtsOutputFile(\n        config: IOutputConfig,\n        parseResult: ITableParseResult,\n        outputFileMap: OutPutFileMap\n    ): void {\n        //如果值没有就不输出类型信息了\n        if (!parseResult.tableObj) return;\n        let dtsFilePath: string = path.join(config.clientDtsOutDir, `${parseResult.tableDefine.tableName}.d.ts`);\n\n        if (!outputFileMap[dtsFilePath]) {\n            //\n            const dtsStr = this._getSingleTableDts(parseResult);\n            if (dtsStr) {\n                outputFileMap[dtsFilePath] = { filePath: dtsFilePath, data: dtsStr } as any;\n            }\n        }\n    }\n    /**\n     * 解析出单个配置表类型数据\n     * @param parseResult\n     */\n    private _getSingleTableDts(parseResult: ITableParseResult): string {\n        const tableName = parseResult.tableDefine.tableName;\n\n        const colKeyTableFieldMap: ColKeyTableFieldMap = parseResult.filedMap;\n        let itemInterface = \"interface IT_\" + tableName + \" {\" + osEol;\n        let tableField: ITableField;\n        let typeStr: string;\n        let objTypeStrMap: { [key: string]: string } = {};\n\n        for (let colKey in colKeyTableFieldMap) {\n            tableField = colKeyTableFieldMap[colKey];\n            if (!tableField) continue;\n            if (!tableField.isMutiColObj) {\n                //注释行\n                itemInterface += \"\\t/** \" + tableField.text + \" */\" + osEol;\n                //字段类型声明行\n                itemInterface +=\n                    \"\\treadonly \" +\n                    tableField.fieldName +\n                    \"?: \" +\n                    (typeStrMap[tableField.type] ? typeStrMap[tableField.type] : tableField.type) +\n                    \";\" +\n                    osEol;\n            } else {\n                const objFieldKey = tableField.fieldName;\n                if (!objTypeStrMap[objFieldKey]) {\n                    objTypeStrMap[objFieldKey] = \"\";\n                }\n\n                //注释行\n                objTypeStrMap[objFieldKey] += \"\\t\\t/** \" + tableField.text + \" */\" + osEol;\n\n                //字段类型声明行\n                objTypeStrMap[objFieldKey] +=\n                    \"\\t\\treadonly \" +\n                    tableField.subFieldName +\n                    \"?: \" +\n                    (typeStrMap[tableField.type] ? typeStrMap[tableField.type] : tableField.type) +\n                    \";\" +\n                    osEol;\n            }\n        }\n        //第二层对象\n        for (let objFieldKey in objTypeStrMap) {\n            //字段类型声明行\n            itemInterface += \"\\treadonly \" + objFieldKey + \"?: {\" + osEol + objTypeStrMap[objFieldKey];\n            itemInterface += \"\\t}\" + osEol;\n        }\n        itemInterface += \"}\" + osEol;\n\n        return itemInterface;\n    }\n    /**\n     * 添加单独导出配置表json文件\n     * @param config\n     * @param parseResult\n     * @param outputFileMap\n     */\n    private _addSingleTableJsonOutputFile(\n        config: IOutputConfig,\n        parseResult: ITableParseResult,\n        outputFileMap: OutPutFileMap\n    ) {\n        const tableObj = parseResult.tableObj;\n        if (!tableObj) return;\n        const tableName = parseResult.tableDefine.tableName;\n        let singleJsonFilePath = path.join(config.clientSingleTableJsonDir, `${tableName}.json`);\n        let singleJsonData = JSON.stringify(tableObj, null, \"\\t\");\n\n        let singleOutputFileInfo = outputFileMap[singleJsonFilePath];\n        if (singleOutputFileInfo) {\n            singleOutputFileInfo.data = singleJsonData;\n        } else {\n            singleOutputFileInfo = {\n                filePath: singleJsonFilePath,\n                data: singleJsonData\n            };\n            outputFileMap[singleJsonFilePath] = singleOutputFileInfo;\n        }\n    }\n    private _getOneTableTypeStr(tableName: string): string {\n        return \"\\treadonly \" + tableName + \"?: \" + \"ITBase<\" + \"IT_\" + tableName + \">;\" + osEol;\n    }\n}\n","export function doParse(\n    parseConfig: ITableConvertConfig,\n    fileInfos: IFileInfo[],\n    parseResultMap: TableParseResultMap,\n    parseHandler: ITableParseHandler\n) {\n    let parseResult;\n    for (let i = fileInfos.length - 1; i >= 0; i--) {\n        parseResult = parseResultMap[fileInfos[i].filePath];\n        if (!parseResult) {\n            parseResult = { filePath: fileInfos[i].filePath };\n        }\n        if (!parseResult.tableObj) {\n            parseResult = parseHandler.parseTableFile(parseConfig, fileInfos[i], parseResult);\n        }\n        if (parseResult) {\n            parseResultMap[fileInfos[i].filePath] = parseResult;\n        }\n    }\n}\n","import * as fs from \"fs-extra\";\nimport * as path from \"path\";\nimport * as crypto from \"crypto\";\nimport { Logger } from \"./loger\";\n\ndeclare global {\n    interface IOutPutFileInfo {\n        filePath: string;\n        /**写入编码，字符串默认utf8 */\n        encoding?: BufferEncoding;\n        /**是否删除 */\n        isDelete?: boolean;\n        data?: any;\n    }\n}\n/**\n * 遍历文件\n * @param dirPath 文件夹路径\n * @param eachCallback 遍历回调 (filePath: string) => void\n */\nexport function forEachFile(fileOrDirPath: string, eachCallback?: (filePath: string) => void) {\n    if (fs.statSync(fileOrDirPath).isDirectory()) {\n        const fileNames = fs.readdirSync(fileOrDirPath);\n        let childFilePath: string;\n        for (var i = 0; i < fileNames.length; i++) {\n            childFilePath = path.join(fileOrDirPath, fileNames[i]);\n            forEachFile(childFilePath, eachCallback);\n        }\n    } else {\n        eachCallback(fileOrDirPath);\n    }\n}\n/**\n * 批量写入和删除文件\n * @param outputFileInfos 需要写入的文件信息数组\n * @param onProgress 进度变化回调\n * @param complete 完成回调\n */\nexport function writeOrDeleteOutPutFiles(\n    outputFileInfos: IOutPutFileInfo[],\n    onProgress?: (filePath: string, total: number, now: number, isOk: boolean) => void,\n    complete?: (total: number) => void\n) {\n    let fileInfo: IOutPutFileInfo;\n    const total = outputFileInfos.length;\n    if (outputFileInfos && total) {\n        let now = 0;\n        const onWriteEnd = (err) => {\n            if (err) {\n                Logger.log(err, \"error\");\n            }\n            now++;\n            onProgress && onProgress(outputFileInfos[now - 1].filePath, total, now, !err);\n            if (now >= total) {\n                complete && complete(total);\n            }\n        };\n        for (let i = outputFileInfos.length - 1; i >= 0; i--) {\n            fileInfo = outputFileInfos[i];\n\n            if (fileInfo.isDelete && fs.existsSync(fileInfo.filePath)) {\n                fs.unlinkSync(fileInfo.filePath);\n            } else {\n                if (fs.existsSync(fileInfo.filePath) && fs.statSync(fileInfo.filePath).isDirectory()) {\n                    Logger.log(`路径为文件夹:${fileInfo.filePath}`, \"error\");\n                    continue;\n                }\n\n                if (!fileInfo.encoding && typeof fileInfo.data === \"string\") {\n                    fileInfo.encoding = \"utf8\";\n                }\n                fs.ensureFileSync(fileInfo.filePath);\n                fs.writeFile(\n                    fileInfo.filePath,\n                    fileInfo.data,\n                    fileInfo.encoding ? { encoding: fileInfo.encoding } : undefined,\n                    onWriteEnd\n                );\n            }\n        }\n    }\n}\n/**\n * 获取变化过的文件数组\n * @param dir 目标目录\n * @param cacheFilePath 缓存文件绝对路径\n * @param eachCallback 遍历回调\n * @returns 返回缓存文件路径\n */\nexport function forEachChangedFile(\n    dir: string,\n    cacheFilePath?: string,\n    eachCallback?: (filePath: string, isDelete?: boolean) => void\n) {\n    const gcfCache = getCacheData(cacheFilePath);\n    const oldFilePaths = Object.keys(gcfCache);\n    let oldFilePathIndex: number;\n    forEachFile(dir, (filePath) => {\n        var md5str = getFileMd5Sync(filePath);\n        if (!gcfCache[filePath] || (gcfCache[filePath] && gcfCache[filePath] !== md5str)) {\n            gcfCache[filePath] = md5str;\n            eachCallback(filePath, false);\n        }\n        oldFilePathIndex = oldFilePaths.indexOf(filePath);\n        if (oldFilePathIndex > -1) {\n            const endFilePath = oldFilePaths[oldFilePaths.length - 1];\n            oldFilePaths[oldFilePathIndex] = endFilePath;\n            oldFilePaths.pop();\n        }\n    });\n    for (let i = 0; i < oldFilePaths.length; i++) {\n        delete gcfCache[oldFilePaths[i]];\n        eachCallback(oldFilePaths[i], true);\n    }\n    fs.writeFileSync(cacheFilePath, JSON.stringify(gcfCache), { encoding: \"utf-8\" });\n}\n/**\n * 写入缓存数据\n * @param cacheFilePath\n * @param cacheData\n */\nexport function writeCacheData(cacheFilePath: string, cacheData: any) {\n    if (!cacheFilePath) {\n        Logger.log(`cacheFilePath is null`, \"error\");\n        return;\n    }\n    fs.writeFileSync(cacheFilePath, JSON.stringify(cacheData), { encoding: \"utf-8\" });\n}\n/**\n * 读取缓存数据\n * @param cacheFilePath\n */\nexport function getCacheData(cacheFilePath: string): any {\n    if (!cacheFilePath) {\n        Logger.log(`cacheFilePath is null`, \"error\");\n        return;\n    }\n    if (!fs.existsSync(cacheFilePath)) {\n        fs.ensureFileSync(cacheFilePath);\n        fs.writeFileSync(cacheFilePath, \"{}\", { encoding: \"utf-8\" });\n    }\n    const gcfCacheFile = fs.readFileSync(cacheFilePath, \"utf-8\");\n    const gcfCache = JSON.parse(gcfCacheFile);\n    return gcfCache;\n}\n/**\n * 获取文件md5 (同步)\n * @param filePath\n */\nexport function getFileMd5Sync(filePath: string): string {\n    const file = fs.readFileSync(filePath, \"utf-8\");\n    var md5um = crypto.createHash(\"md5\");\n    md5um.update(file);\n    return md5um.digest(\"hex\");\n}\n/**\n * 获取文件 md5\n * @param filePath\n */\nexport async function getFileMd5(filePath: string) {\n    return getFileMd5Sync(filePath);\n}\n","import * as path from \"path\";\nimport * as fs from \"fs-extra\";\nimport * as mmatch from \"micromatch\";\nimport { forEachFile, getCacheData, getFileMd5Sync, writeCacheData, writeOrDeleteOutPutFiles } from \"./file-utils\";\nimport { Worker } from \"worker_threads\";\nimport { doParse } from \"./do-parse\";\nimport { DefaultParseHandler } from \"./default-parse-handler\";\nimport { Logger } from \"./loger\";\nimport { DefaultConvertHook } from \"./default-convert-hook\";\nimport { DefaultOutPutTransformer } from \"./default-output-transformer\";\nconst defaultDir = \".excel2all\";\nconst cacheFileName = \".e2aprmc\";\nconst logFileName = \"excel2all.log\"\n/**\n * 转换\n * @param converConfig 解析配置\n */\nexport async function convert(converConfig: ITableConvertConfig) {\n    if (!converConfig.projRoot) {\n        converConfig.projRoot = process.cwd();\n    }\n    let convertHook: IConvertHook;\n    if (converConfig.customConvertHookPath) {\n        convertHook = require(converConfig.customConvertHookPath);\n    } else {\n        convertHook = new DefaultConvertHook();\n    }\n    let outputTransformer: IOutPutTransformer;\n    if (converConfig.customOutPutTransformerPath) {\n        outputTransformer = require(converConfig.customOutPutTransformerPath);\n    } else {\n        outputTransformer = new DefaultOutPutTransformer();\n    }\n    const tableFileDir = converConfig.tableFileDir;\n    if (!tableFileDir) {\n        Logger.log(`配置表目录：tableFileDir为空`, \"error\");\n        return;\n    }\n    if (!fs.existsSync(tableFileDir)) {\n        Logger.log(`配置表文件夹不存在：${tableFileDir}`, \"error\");\n        return;\n    }\n    const defaultPattern = [\"**/*.{xlsx,csv}\", \"!**/~$*.*\", \"!**/~.*.*\"];\n    if (!converConfig.pattern) {\n        converConfig.pattern = defaultPattern;\n    }\n    if (converConfig.useMultiThread && isNaN(converConfig.threadParseFileMaxNum)) {\n        converConfig.threadParseFileMaxNum = 5;\n    }\n    Logger.init(converConfig);\n    const context: IConvertContext = {\n        convertConfig: converConfig,\n        outputTransformer: outputTransformer\n    } as any;\n    //开始\n    await new Promise<void>((res) => {\n        convertHook.onStart(context, res);\n    });\n\n    let changedFileInfos: IFileInfo[] = [];\n    let deleteFileInfos: IFileInfo[] = [];\n    const getFileInfo = (filePath: string) => {\n        const filePathParse = path.parse(filePath);\n        const fileInfo: IFileInfo = {\n            filePath: filePath,\n            fileName: filePathParse.name,\n            fileExtName: filePathParse.ext,\n            isDelete: false\n        };\n        return fileInfo;\n    };\n    const matchPattern = converConfig.pattern;\n    const eachFileCallback = (filePath: string, isDelete?: boolean) => {\n        const fileInfo = getFileInfo(filePath);\n        let canRead: boolean;\n        if (isDelete) {\n            deleteFileInfos.push(fileInfo);\n        } else {\n            canRead = mmatch.all(fileInfo.filePath, matchPattern);\n            if (canRead) {\n                changedFileInfos.push(fileInfo);\n            }\n        }\n        return { fileInfo, canRead };\n    };\n    let parseResultMap: TableParseResultMap = {};\n\n    //缓存处理\n    let cacheFileDirPath: string = converConfig.cacheFileDirPath;\n    let parseResultMapCacheFilePath: string;\n\n    if (!converConfig.useCache) {\n        forEachFile(tableFileDir, eachFileCallback);\n    } else {\n        if (!cacheFileDirPath) cacheFileDirPath = defaultDir;\n        if (!path.isAbsolute(cacheFileDirPath)) {\n            cacheFileDirPath = path.join(converConfig.projRoot, cacheFileDirPath);\n        }\n        parseResultMapCacheFilePath = path.join(cacheFileDirPath, cacheFileName);\n        parseResultMap = getCacheData(parseResultMapCacheFilePath);\n        if (!parseResultMap) {\n            parseResultMap = {};\n        }\n        const oldFilePaths = Object.keys(parseResultMap);\n        let oldFilePathIndex: number;\n        let parseResult: ITableParseResult;\n        forEachFile(tableFileDir, (filePath) => {\n            var md5str = getFileMd5Sync(filePath);\n            parseResult = parseResultMap[filePath];\n            if (!parseResult) {\n                parseResult = {\n                    filePath: filePath\n                };\n                parseResultMap[filePath] = parseResult;\n            }\n            if (parseResult && parseResult.md5hash !== md5str) {\n                const { fileInfo, canRead } = eachFileCallback(filePath, false);\n                if (canRead) {\n                    parseResult.md5hash = md5str;\n                }\n            }\n            oldFilePathIndex = oldFilePaths.indexOf(filePath);\n            if (oldFilePathIndex > -1) {\n                const endFilePath = oldFilePaths[oldFilePaths.length - 1];\n                oldFilePaths[oldFilePathIndex] = endFilePath;\n                oldFilePaths.pop();\n            }\n        });\n        for (let i = 0; i < oldFilePaths.length; i++) {\n            delete parseResultMap[oldFilePaths[i]];\n            eachFileCallback(oldFilePaths[i], true);\n        }\n    }\n\n    let parseHandler: ITableParseHandler;\n    if (converConfig.customParseHandlerPath) {\n        parseHandler = require(converConfig.customParseHandlerPath);\n        if (!parseHandler || typeof parseHandler.parseTableFile !== \"function\") {\n            console.error(`自定义解析实现错误:${converConfig.customParseHandlerPath}`);\n            return;\n        }\n    } else {\n        parseHandler = new DefaultParseHandler();\n    }\n    //解析开始之前\n    context.parseResultMap = parseResultMap;\n    context.deleteFileInfos = deleteFileInfos;\n    context.changedFileInfos = changedFileInfos;\n    await new Promise<void>((res) => {\n        convertHook.onParseBefore(context, res);\n    });\n\n    if (changedFileInfos.length > converConfig.threadParseFileMaxNum && converConfig.useMultiThread) {\n        let logStr: string = \"\";\n        const count = Math.floor(changedFileInfos.length / converConfig.threadParseFileMaxNum) + 1;\n        let worker: Worker;\n        let subFileInfos: IFileInfo[];\n        let workerMap: { [key: number]: Worker } = {};\n        let completeCount: number = 0;\n        const t1 = new Date().getTime();\n        const onWorkerParseEnd = (data: IWorkDoResult) => {\n            Logger.log(`----------------线程结束:${data.threadId}-----------------`);\n            const parsedMap = data.parseResultMap;\n            for (let key in parsedMap) {\n                if (!parseResultMap[key].tableDefine) {\n                    parseResultMap[key] = parsedMap[key];\n                }\n            }\n            completeCount++;\n            logStr += data.logStr + Logger.logStr;\n            if(!context.hasError){\n                context.hasError = Logger.hasError;\n            }\n            if (completeCount >= count) {\n                const t2 = new Date().getTime();\n                Logger.log(`[多线程导表时间]:${t2 - t1}`);\n                onParseEnd(context, parseResultMapCacheFilePath, convertHook, logStr);\n            }\n        };\n        for (let i = 0; i < count; i++) {\n            subFileInfos = changedFileInfos.splice(0, converConfig.threadParseFileMaxNum);\n            Logger.log(`----------------线程开始:${i}-----------------`);\n            worker = new Worker(path.join(path.dirname(__filename), \"../../../worker_scripts/worker.js\"), {\n                workerData: {\n                    threadId: i,\n                    fileInfos: subFileInfos,\n                    parseResultMap: parseResultMap,\n                    convertConfig: converConfig\n                } as IWorkerShareData\n            });\n            workerMap[i] = worker;\n            worker.on(\"message\", onWorkerParseEnd);\n        }\n    } else {\n        const t1 = new Date().getTime();\n\n        doParse(converConfig, changedFileInfos, parseResultMap, parseHandler);\n        const t2 = new Date().getTime();\n        Logger.systemLog(`[单线程导表时间]:${t2 - t1}`);\n        context.hasError = Logger.hasError;\n        onParseEnd(context, parseResultMapCacheFilePath, convertHook);\n    }\n}\n/**\n * 解析结束\n * @param parseConfig\n * @param parseResultMapCacheFilePath\n * @param convertHook\n * @param fileInfos\n * @param deleteFileInfos\n * @param parseResultMap\n * @param logStr\n */\nasync function onParseEnd(\n    context: IConvertContext,\n    parseResultMapCacheFilePath: string,\n    convertHook: IConvertHook,\n    logStr?: string\n) {\n    const convertConfig = context.convertConfig;\n    const parseResultMap = context.parseResultMap;\n    //如果没有错误,则写入解析缓存\n    //有错误不能写入缓存，避免错误被下次解析给忽略掉\n    if (convertConfig.useCache && !context.hasError) {\n        writeCacheData(parseResultMapCacheFilePath, parseResultMap);\n    }\n    //解析结束，做导出处理\n    await new Promise<void>((res) => {\n        convertHook.onParseAfter(context, res);\n    });\n\n    if (context.outPutFileMap) {\n        const outputFileMap = context.outPutFileMap;\n        const outputFiles = Object.values(outputFileMap);\n        //写入和删除文件处理\n        Logger.systemLog(`开始写入文件:0/${outputFiles.length}`);\n\n        await new Promise<void>((res) => {\n            writeOrDeleteOutPutFiles(\n                outputFiles,\n                (filePath, total, now, isOk) => {\n                    Logger.log(`[写入文件] 进度:(${now}/${total}) 路径:${filePath}`);\n                },\n                () => {\n                    res();\n                }\n            );\n        });\n        Logger.systemLog(`写入结束~`);\n    } else {\n        Logger.systemLog(`没有可写入文件~`);\n    }\n\n    //写入日志文件\n\n    if (!logStr) {\n        logStr = Logger.logStr;\n    }\n    if (logStr.trim() !== \"\") {\n        let logFileDirPath = context.convertConfig.outputLogDirPath as string;\n        if (!logFileDirPath) logFileDirPath = defaultDir;\n        if (!path.isAbsolute(logFileDirPath)) {\n            logFileDirPath = path.join(context.convertConfig.projRoot, logFileDirPath);\n        }\n\n        const outputLogFileInfo: IOutPutFileInfo = {\n            filePath: path.join(logFileDirPath, logFileName),\n            data: logStr\n        };\n        writeOrDeleteOutPutFiles([outputLogFileInfo]);\n    }\n    //写入结束\n    convertHook.onWriteFileEnd(context);\n}\n/**\n * 测试文件匹配\n * @param converConfig\n */\nexport function testFileMatch(converConfig: ITableConvertConfig) {\n    if (!converConfig.projRoot) {\n        converConfig.projRoot = process.cwd();\n    }\n    let convertHook: IConvertHook;\n    if (converConfig.customConvertHookPath) {\n        convertHook = require(converConfig.customConvertHookPath);\n    } else {\n        convertHook = new DefaultConvertHook();\n    }\n    const tableFileDir = converConfig.tableFileDir;\n    if (!tableFileDir) {\n        Logger.log(`配置表目录：tableFileDir为空`, \"error\");\n        return;\n    }\n    if (!fs.existsSync(tableFileDir)) {\n        Logger.log(`配置表文件夹不存在：${tableFileDir}`, \"error\");\n        return;\n    }\n    const defaultPattern = [\"**/*.{xlsx,csv}\", \"!**/~$*.*\", \"!**/~.*.*\"];\n    if (!converConfig.pattern) {\n        converConfig.pattern = defaultPattern;\n    }\n    if (converConfig.useMultiThread && isNaN(converConfig.threadParseFileMaxNum)) {\n        converConfig.threadParseFileMaxNum = 5;\n    }\n    const matchPattern = converConfig.pattern;\n    const deleteFilePaths: string[] = [];\n    const changedFilePaths: string[] = [];\n    const eachFileCallback = (filePath: string, isDelete?: boolean) => {\n        let canRead: boolean;\n        if (isDelete) {\n            deleteFilePaths.push(filePath);\n        } else {\n            canRead = mmatch.all(filePath, matchPattern);\n            if (canRead) {\n                changedFilePaths.push(filePath);\n            }\n        }\n        return { canRead };\n    };\n    let cacheFileDirPath: string = converConfig.cacheFileDirPath;\n    let parseResultMapCacheFilePath: string;\n    let parseResultMap: TableParseResultMap;\n    if (!converConfig.useCache) {\n        forEachFile(tableFileDir, eachFileCallback);\n    } else {\n        if (!cacheFileDirPath) cacheFileDirPath = \".cache\";\n        if (!path.isAbsolute(cacheFileDirPath)) {\n            cacheFileDirPath = path.join(converConfig.projRoot, cacheFileDirPath);\n        }\n        parseResultMapCacheFilePath = path.join(cacheFileDirPath, \".egfprmc\");\n        parseResultMap = getCacheData(parseResultMapCacheFilePath);\n        if (!parseResultMap) {\n            parseResultMap = {};\n        }\n        const oldFilePaths = Object.keys(parseResultMap);\n        let oldFilePathIndex: number;\n        let parseResult: ITableParseResult;\n        forEachFile(tableFileDir, (filePath) => {\n            var md5str = getFileMd5Sync(filePath);\n            parseResult = parseResultMap[filePath];\n            if (!parseResult) {\n                parseResult = {\n                    filePath: filePath\n                };\n                parseResultMap[filePath] = parseResult;\n            }\n            if (parseResult && parseResult.md5hash !== md5str) {\n                const { canRead } = eachFileCallback(filePath, false);\n                if (canRead) {\n                    parseResult.md5hash = md5str;\n                }\n            }\n            oldFilePathIndex = oldFilePaths.indexOf(filePath);\n            if (oldFilePathIndex > -1) {\n                const endFilePath = oldFilePaths[oldFilePaths.length - 1];\n                oldFilePaths[oldFilePathIndex] = endFilePath;\n                oldFilePaths.pop();\n            }\n        });\n        for (let i = 0; i < oldFilePaths.length; i++) {\n            delete parseResultMap[oldFilePaths[i]];\n            eachFileCallback(oldFilePaths[i], true);\n        }\n    }\n    if (converConfig.useCache) {\n        console.log(`----【缓存模式】----`);\n    }\n    console.log(`------------------------------匹配到的文件---------------------`);\n    console.log(changedFilePaths);\n}\n"],"names":["os.platform","xlsx.readFile","TableType","path.join","deflateSync","fs.statSync","fs.readdirSync","fs.existsSync","fs.unlinkSync","fs.ensureFileSync","fs.writeFile","fs.writeFileSync","fs.readFileSync","crypto.createHash","path.parse","mmatch.all","path.isAbsolute","Worker","path.dirname"],"mappings":"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"}