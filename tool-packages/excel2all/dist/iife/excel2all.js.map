{"version":3,"file":"excel2all.js","sources":["@ailhc/excel2all/src/default-value-func-map.ts","@ailhc/excel2all/src/get-os-eol.ts","@ailhc/excel2all/src/loger.ts","@ailhc/excel2all/src/table-utils.ts","@ailhc/excel2all/src/default-parse-handler.ts","@ailhc/excel2all/src/default-convert-hook.ts","@ailhc/excel2all/src/default-output-transformer.ts","@ailhc/excel2all/src/do-parse.ts","@ailhc/excel2all/src/file-utils.ts","@ailhc/excel2all/src/convert.ts"],"sourcesContent":["import { Logger } from \"./loger\";\n\nexport const valueTransFuncMap: {\n    [key: string]: ValueTransFunc;\n} = {};\nvalueTransFuncMap[\"int\"] = strToInt;\nvalueTransFuncMap[\"string\"] = anyToStr;\nvalueTransFuncMap[\"[int]\"] = strToIntArr;\nvalueTransFuncMap[\"[string]\"] = strToStrArr;\nvalueTransFuncMap[\"json\"] = strToJsonObj;\nfunction strToIntArr(fieldItem: ITableField, cellValue: string): ITransValueResult {\n    cellValue = (cellValue + \"\").replace(/，/g, \",\"); //为了防止策划误填，先进行转换\n    cellValue = cellValue.trim();\n    let intArr: number[];\n    const result: ITransValueResult = {};\n    if (cellValue !== \"\") {\n        try {\n            intArr = JSON.parse(cellValue);\n            result.value = intArr;\n        } catch (error) {\n            result.error = error;\n        }\n    }\n\n    return result;\n}\nfunction strToStrArr(fieldItem: ITableField, cellValue: string): ITransValueResult {\n    cellValue = (cellValue + \"\").replace(/，/g, \",\"); //为了防止策划误填，先进行转换\n    cellValue = cellValue.trim();\n    let result: ITransValueResult = {};\n    let arr: string[];\n    if (cellValue !== \"\") {\n        try {\n            arr = JSON.parse(cellValue);\n            result.value = arr;\n        } catch (error) {\n            result.error = error;\n        }\n    }\n    return result;\n}\nfunction strToInt(fieldItem: ITableField, cellValue: string): ITransValueResult {\n    let result: ITransValueResult = {} as any;\n    if (typeof cellValue === \"string\" && cellValue.trim() !== \"\") {\n        result.value = cellValue.includes(\".\") ? parseFloat(cellValue) : (parseInt(cellValue) as any);\n    } else if (typeof cellValue === \"number\") {\n        result.value = cellValue;\n    }\n    return result;\n}\nfunction strToJsonObj(fieldItem: ITableField, cellValue: string): ITransValueResult {\n    cellValue = (cellValue + \"\").replace(/，/g, \",\"); //为了防止策划误填，先进行转换\n    cellValue = cellValue.trim();\n    let obj;\n    let error;\n    if (cellValue !== \"\") {\n        try {\n            obj = JSON.parse(cellValue);\n        } catch (err) {\n            error = err;\n            obj = cellValue;\n        }\n    }\n    return { error: error, value: obj };\n}\nfunction anyToStr(fieldItem: ITableField, cellValue: any): ITransValueResult {\n    let result: ITransValueResult = {} as any;\n    if (typeof cellValue === \"string\") {\n        cellValue = cellValue.trim();\n        if (cellValue !== \"\") {\n            result.value = cellValue;\n        }\n    } else {\n        result.value = cellValue + \"\";\n    }\n    return result;\n}\n","import * as os from \"os\";\nconst platform = os.platform();\n/**当前系统行尾  platform === \"win32\" ? \"\\n\" : \"\\r\\n\";*/\nexport const osEol = platform === \"win32\" ? \"\\n\" : \"\\r\\n\";\n","import { osEol } from \"./get-os-eol\";\nimport * as path from \"path\";\nenum LogLevelEnum {\n    info,\n    warn,\n    error,\n    no\n}\nexport class Logger {\n    private static _enableOutPutLogFile: boolean;\n    private static _logLevel: LogLevelEnum;\n    private static _logStr: string = \"\";\n    /**\n     * 如果有输出过错误信息则为true\n     */\n    public static hasError: boolean = false;\n    public static init(convertConfig: ITableConvertConfig) {\n        const level: LogLevel = convertConfig.logLevel ? convertConfig.logLevel : \"info\";\n        this._logLevel = LogLevelEnum[level];\n        this._enableOutPutLogFile = convertConfig.outputLogDirPath === false ? false : true;\n    }\n    /**\n     * 输出日志,日志等级只是限制了控制台输出，但不限制日志记录\n     * @param message\n     * @param level\n     */\n    public static log(message: string, level: LogLevel = \"info\") {\n        if (level !== \"no\") {\n            if (this._logLevel <= LogLevelEnum[level]) {\n                switch (level) {\n                    case \"error\":\n                        console.error(message);\n                        if (!this.hasError) this.hasError = true;\n                        break;\n                    case \"info\":\n                        console.log(message);\n                        break;\n                    case \"warn\":\n                        console.warn(message);\n                        break;\n                }\n            }\n        }\n\n        if (!this._enableOutPutLogFile) return;\n        this._logStr += message + osEol;\n    }\n    /**\n     * 系统日志输出\n     * @param args\n     */\n    public static systemLog(message: string) {\n        console.log(message);\n        if (!this._enableOutPutLogFile) return;\n        this._logStr += message + osEol;\n    }\n    /**\n     * 返回日志数据并清空\n     */\n    public static get logStr(): string {\n        if (!this._enableOutPutLogFile) return null;\n        const logStr = this._logStr;\n        this._logStr = \"\"; //清空\n        return logStr;\n    }\n}\n","import * as xlsx from \"xlsx\";\n/**\n * 是否为空表格格子\n * @param cell\n */\nexport function isEmptyCell(cell: xlsx.CellObject) {\n    if (cell && cell.v !== undefined) {\n        if (typeof cell.v === \"string\") {\n            return cell.v === \"\";\n        } else if (typeof cell.v === \"number\") {\n            return isNaN(cell.v);\n        } else {\n            return false;\n        }\n    } else {\n        return true;\n    }\n}\n/**\n * 字母Z的编码\n */\nexport const ZCharCode = 90;\n/**\n * 字母A的编码\n *\n */\nexport const ACharCode = 65;\n/**\n * 根据当前列的charCodes获取下一列Key\n * @param charCodes\n */\nexport function getNextColKey(charCodes: number[]): string {\n    let isAdd: boolean;\n    for (let i = charCodes.length - 1; i >= 0; i--) {\n        if (charCodes[i] < ZCharCode) {\n            charCodes[i] += 1;\n            isAdd = true;\n            break;\n        } else if (charCodes[i] === ZCharCode) {\n            charCodes[i] = ACharCode;\n        }\n    }\n    if (!isAdd) {\n        charCodes.push(ACharCode);\n    }\n\n    return charCodesToString(charCodes);\n}\n\n/**\n * 列的字符编码数组转字符串\n * @param charCodes\n */\nexport function charCodesToString(charCodes: number[]): string {\n    return String.fromCharCode(...charCodes);\n}\n/**\n * 字符串转编码数组\n * @param colKey\n */\nexport function stringToCharCodes(colKey: string) {\n    const charCodes = [];\n    for (let i = 0; i < colKey.length; i++) {\n        charCodes.push(colKey.charCodeAt(i));\n    }\n    return charCodes;\n}\n/**\n * 纵向遍历表格\n * @param sheet xlsx表格对象\n * @param startRow 开始行 从1开始\n * @param startCol 列字符 比如A B\n * @param callback 遍历回调 (sheet: xlsx.Sheet, colKey: string, rowIndex: number) => void\n * @param isSheetRowEnd 是否行结束判断方法\n * @param isSheetColEnd 是否列结束判断方法\n * @param isSkipSheetRow 是否跳过行\n * @param isSkipSheetCol 是否跳过列\n */\nexport function verticalForEachSheet(\n    sheet: xlsx.Sheet,\n    startRow: number,\n    startCol: string,\n    callback: (sheet: xlsx.Sheet, colKey: string, rowIndex: number) => void,\n    isSheetRowEnd?: (sheet: xlsx.Sheet, rowIndex: number) => boolean,\n    isSheetColEnd?: (sheet: xlsx.Sheet, colkey: string) => boolean,\n    isSkipSheetRow?: (sheet: xlsx.Sheet, rowIndex: number) => boolean,\n    isSkipSheetCol?: (sheet: xlsx.Sheet, colKey: string) => boolean\n) {\n    const sheetRef: string = sheet[\"!ref\"];\n    const maxRowNum = parseInt(sheetRef.match(/\\d+$/)[0]);\n\n    const maxColKey = sheetRef.split(\":\")[1].match(/^[A-Za-z]+/)[0];\n    let maxColKeyCodeSum = getCharCodeSum(maxColKey);\n\n    let colCharCodes: number[];\n    let colKey: string;\n    let curColCodeSum: number = 0;\n    const startCharcodes = stringToCharCodes(startCol);\n    for (let i = startRow; i <= maxRowNum; i++) {\n        if (isSheetRowEnd ? isSheetRowEnd(sheet, i) : false) break;\n        if (isSkipSheetRow ? isSkipSheetRow(sheet, i) : false) continue;\n        colCharCodes = startCharcodes.concat([]);\n\n        colKey = startCol;\n\n        let hasNextCol = isSheetColEnd ? !isSheetColEnd(sheet, colKey) : true;\n        while (hasNextCol) {\n            if (!(isSkipSheetCol ? isSkipSheetCol(sheet, colKey) : false)) {\n                callback(sheet, colKey, i);\n            }\n            colKey = getNextColKey(colCharCodes);\n            curColCodeSum = getCharCodeSum(colKey);\n            if (maxColKeyCodeSum >= curColCodeSum) {\n                hasNextCol = isSheetColEnd ? !isSheetColEnd(sheet, colKey) : true;\n            } else {\n                hasNextCol = false;\n            }\n        }\n    }\n}\n\n/**\n * 横向遍历表格\n * @param sheet xlsx表格对象\n * @param startRow 开始行 从1开始\n * @param startCol 列字符 比如A B\n * @param callback 遍历回调 (sheet: xlsx.Sheet, colKey: string, rowIndex: number) => void\n * @param isSheetRowEnd 是否行结束判断方法\n * @param isSheetColEnd 是否列结束判断方法\n * @param isSkipSheetRow 是否跳过行\n * @param isSkipSheetCol 是否跳过列\n */\nexport function horizontalForEachSheet(\n    sheet: xlsx.Sheet,\n    startRow: number,\n    startCol: string,\n    callback: (sheet: xlsx.Sheet, colKey: string, rowIndex: number) => void,\n    isSheetRowEnd?: (sheet: xlsx.Sheet, rowIndex: number) => boolean,\n    isSheetColEnd?: (sheet: xlsx.Sheet, colkey: string) => boolean,\n    isSkipSheetRow?: (sheet: xlsx.Sheet, rowIndex: number) => boolean,\n    isSkipSheetCol?: (sheet: xlsx.Sheet, colKey: string) => boolean\n) {\n    const sheetRef: string = sheet[\"!ref\"];\n    const maxRowNum = parseInt(sheetRef.match(/\\d+$/)[0]);\n\n    const maxColKey = sheetRef.split(\":\")[1].match(/^[A-Za-z]+/)[0];\n    const maxColKeyCodeSum = getCharCodeSum(maxColKey);\n    let colCharCodes: number[];\n    let colKey: string;\n    colCharCodes = stringToCharCodes(startCol);\n    let curColCodeSum: number = 0;\n    colKey = startCol;\n    let hasNextCol = isSheetColEnd ? !isSheetColEnd(sheet, colKey) : true;\n    while (hasNextCol) {\n        if (!(isSkipSheetCol ? isSkipSheetCol(sheet, colKey) : false)) {\n            for (let i = startRow; i <= maxRowNum; i++) {\n                if (isSheetRowEnd ? isSheetRowEnd(sheet, i) : false) break;\n                if (isSkipSheetRow ? isSkipSheetRow(sheet, i) : false) continue;\n                callback(sheet, colKey, i);\n            }\n        }\n\n        colKey = getNextColKey(colCharCodes);\n        curColCodeSum = getCharCodeSum(colKey);\n        if (maxColKeyCodeSum >= curColCodeSum) {\n            hasNextCol = isSheetColEnd ? !isSheetColEnd(sheet, colKey) : true;\n        } else {\n            hasNextCol = false;\n        }\n    }\n}\nlet colKeySumMap = {};\nfunction getCharCodeSum(colKey: string): number {\n    let sum: number = colKeySumMap[colKey];\n    if (!sum) {\n        sum = 0;\n        for (let i = 0; i < colKey.length; i++) {\n            sum += colKey.charCodeAt(i);\n        }\n        colKeySumMap[colKey] = sum;\n    }\n    return sum;\n}\n/**\n * 读取配置表文件 同步的\n * @param fileInfo\n */\nexport function readTableFile(fileInfo: IFileInfo): xlsx.WorkBook {\n    const workBook = xlsx.readFile(fileInfo.filePath, { type: isCSV(fileInfo.fileExtName) ? \"string\" : \"file\" });\n    return workBook;\n}\n/**\n * 根据文件名后缀判断是否为csv文件\n * @param fileExtName\n */\nexport function isCSV(fileExtName: string): boolean {\n    return fileExtName === \"csv\";\n}\n","import * as xlsx from \"xlsx\";\nimport { valueTransFuncMap } from \"./default-value-func-map\";\nimport { Logger } from \"./loger\";\nimport { horizontalForEachSheet, isEmptyCell, readTableFile, verticalForEachSheet } from \"./table-utils\";\n\ndeclare global {\n    interface ITableField {\n        /**配置表中注释值 */\n        text: string;\n        /**配置表中类型值 */\n        originType: string;\n        /**配置表中字段名值 */\n        originFieldName: string;\n        /**解析后的类型值 */\n        type?: string;\n        /**解析后的字段名值 */\n        fieldName?: string;\n        /**对象的子字段名 */\n        subFieldName?: string;\n        /**多列对象 */\n        isMutiColObj?: boolean;\n    }\n    interface ITableDefine {\n        /**配置表名 */\n        tableName: string;\n        /**配置表类型 默认两种: vertical 和 horizontal*/\n        tableType: string;\n\n        /**开始行从1开始 */\n        startRow: number;\n        /**开始列从A开始 */\n        startCol: string;\n        /**垂直解析字段定义 */\n        verticalFieldDefine: IVerticalFieldDefine;\n        /**横向解析字段定义 */\n        horizontalFieldDefine: IHorizontalFieldDefine;\n    }\n    interface IHorizontalFieldDefine {\n        /**类型行 */\n        typeCol: string;\n        /**字段名行 */\n        fieldCol: string;\n        /**注释行 */\n        textCol: string;\n    }\n    interface IVerticalFieldDefine {\n        /**类型行 */\n        typeRow: number;\n        /**字段名行 */\n        fieldRow: number;\n        /**注释行 */\n        textRow: number;\n    }\n    /**\n     * 字段字典\n     * key是列colKey\n     * value是字段对象\n     */\n    type ColKeyTableFieldMap = { [key: string]: ITableField };\n\n    /**\n     * 表格的一行或者一列\n     * key为字段名值，value为表格的一格\n     */\n    type TableRowOrCol = { [key: string]: ITableCell };\n    /**\n     * 表格的一格\n     */\n    interface ITableCell {\n        /**字段对象 */\n        filed: ITableField;\n        /**值 */\n        value: any;\n    }\n    /**\n     * 表格行或列的字典\n     * key为行索引，value为表格的一行\n     */\n    type TableRowOrColMap = { [key: string]: TableRowOrCol };\n    /**\n     * 表格行或列值数组\n     * key主键，value是值数组\n     */\n    type RowOrColValuesMap = { [key: string]: any[] };\n    interface ITableValues {\n        /**字段名数组 */\n        fields: string[];\n        /**表格值数组 */\n        rowOrColValuesMap: RowOrColValuesMap;\n    }\n    /**\n     * 解析结果\n     */\n    interface ITableParseResult {\n        /**配置表定义 */\n        tableDefine?: ITableDefine;\n        /**当前分表名 */\n        curSheetName?: string;\n        /**字段字典 */\n        filedMap?: ColKeyTableFieldMap;\n        // /**表格行或列的字典 */\n        // rowOrColMap: TableRowOrColMap\n        /**单个表格对象 */\n        /**key是主键值，value是一行对象 */\n        tableObj?: { [key: string]: any };\n        /**当前行或列对象 */\n        curRowOrColObj?: any;\n        /**主键值 */\n        mainKeyFieldName?: string;\n    }\n\n    /**值转换方法 */\n    interface ITransValueResult {\n        error?: any;\n        value?: any;\n    }\n    type ValueTransFunc = (fieldItem: ITableField, cellValue: any) => ITransValueResult;\n    /**\n     * 值转换方法字典\n     * key是类型key\n     * value是方法\n     */\n    type ValueTransFuncMap = { [key: string]: ValueTransFunc };\n}\nexport enum TableType {\n    vertical = \"vertical\",\n    horizontal = \"horizontal\"\n}\n\nexport class DefaultParseHandler implements ITableParseHandler {\n    private _valueTransFuncMap: ValueTransFuncMap;\n    constructor() {\n        this._valueTransFuncMap = valueTransFuncMap;\n    }\n    getTableDefine(fileInfo: IFileInfo, workBook: xlsx.WorkBook): ITableDefine {\n        //取表格文件名为表格名\n        const tableName = fileInfo.fileName;\n\n        const tableDefine: Partial<ITableDefine> = {\n            tableName: tableName\n        };\n\n        let cellKey: string;\n        let cellObj: xlsx.CellObject;\n        //取第一个表\n        const sheetNames = workBook.SheetNames;\n        let sheet: xlsx.Sheet;\n        let firstCellValue: { tableNameInSheet: string; tableType: string };\n        let firstCellObj: xlsx.CellObject;\n        for (let i = 0; i < sheetNames.length; i++) {\n            sheet = workBook.Sheets[sheetNames[i]];\n            firstCellObj = sheet[\"A\" + 1];\n            if (!isEmptyCell(firstCellObj)) {\n                firstCellValue = this._getFirstCellValue(firstCellObj);\n                if (firstCellValue && firstCellValue.tableNameInSheet === tableName) {\n                    break;\n                }\n            }\n        }\n        if (!firstCellValue || firstCellValue.tableNameInSheet !== tableName) {\n            Logger.log(`表格不规范,跳过解析,路径:${fileInfo.filePath}`, \"error\");\n            return null;\n        }\n        tableDefine.tableType = firstCellValue.tableType;\n        if (tableDefine.tableType === TableType.vertical) {\n            tableDefine.verticalFieldDefine = {} as any;\n            const verticalFieldDefine: IVerticalFieldDefine = tableDefine.verticalFieldDefine;\n            verticalFieldDefine.textRow = 1;\n            for (let i = 1; i < 100; i++) {\n                cellKey = \"A\" + i;\n                cellObj = sheet[cellKey];\n                if (isEmptyCell(cellObj) || cellObj.v === \"NO\" || cellObj.v === \"END\" || cellObj.v === \"START\") {\n                    tableDefine.startRow = i;\n                } else if (cellObj.v === \"CLIENT\") {\n                    verticalFieldDefine.fieldRow = i;\n                } else if (cellObj.v === \"TYPE\") {\n                    verticalFieldDefine.typeRow = i;\n                }\n                if (tableDefine.startRow && verticalFieldDefine.fieldRow && verticalFieldDefine.typeRow) break;\n            }\n\n            tableDefine.startCol = \"B\";\n        } else if (tableDefine.tableType === TableType.horizontal) {\n            tableDefine.horizontalFieldDefine = {} as any;\n            const horizontalFieldDefine = tableDefine.horizontalFieldDefine;\n            horizontalFieldDefine.textCol = \"A\";\n            horizontalFieldDefine.typeCol = \"B\";\n            horizontalFieldDefine.fieldCol = \"C\";\n            tableDefine.startCol = \"E\";\n            tableDefine.startRow = 2;\n        }\n\n        return tableDefine as any;\n    }\n    private _getFirstCellValue(firstCellObj: xlsx.CellObject) {\n        if (!firstCellObj) return;\n        const cellValues = (firstCellObj.v as string).split(\":\");\n        let tableNameInSheet: string;\n        let tableType: string;\n        if (cellValues.length > 1) {\n            tableNameInSheet = cellValues[1];\n            tableType = cellValues[0] === \"H\" ? TableType.horizontal : TableType.vertical;\n        } else {\n            tableNameInSheet = cellValues[0];\n            tableType = TableType.vertical;\n        }\n        return { tableNameInSheet: tableNameInSheet, tableType: tableType };\n    }\n    /**\n     * 判断表格是否能解析\n     * @param sheet\n     */\n    checkSheetCanParse(tableDefine: ITableDefine, sheet: xlsx.Sheet, sheetName: string): boolean {\n        //如果这个表个第一格值不等于表名，则不解析\n        const firstCellObj: xlsx.CellObject = sheet[\"A\" + 1];\n        const firstCellValue = this._getFirstCellValue(firstCellObj);\n        if (firstCellObj && tableDefine) {\n            if (firstCellValue.tableNameInSheet !== tableDefine.tableName) {\n                return false;\n            }\n            return true;\n        } else {\n            return false;\n        }\n    }\n    /**\n     * 表行结束判断\n     * @param tableDefine\n     * @param sheet\n     * @param row\n     */\n    isSheetRowEnd(tableDefine: ITableDefine, sheet: xlsx.Sheet, row: number): boolean {\n        // if (tableDefine.tableType === TableType.vertical) {\n\n        // } else if (tableDefine.tableType === TableType.horizontal) {\n\n        // }\n        //判断上一行的标志是否为END\n        if (row > 1) {\n            row = row - 1;\n            const cellObj: xlsx.CellObject = sheet[\"A\" + row];\n            return cellObj && cellObj.v === \"END\";\n        } else {\n            return false;\n        }\n    }\n    /**\n     * 表列结束判断\n     * @param tableDefine\n     * @param sheet\n     * @param colKey\n     */\n    isSheetColEnd(tableDefine: ITableDefine, sheet: xlsx.Sheet, colKey: string): boolean {\n        //判断这一列第一行是否为空\n        const firstCellObj: xlsx.CellObject = sheet[colKey + 1];\n        // const typeCellObj: xlsx.CellObject = sheet[colKey + tableFile.tableDefine.typeRow];\n        return isEmptyCell(firstCellObj);\n    }\n    /**\n     * 检查行是否需要解析\n     * @param tableDefine\n     * @param sheet\n     * @param rowIndex\n     */\n    checkRowNeedParse(tableDefine: ITableDefine, sheet: xlsx.Sheet, rowIndex: number): boolean {\n        const cellObj: xlsx.CellObject = sheet[\"A\" + rowIndex];\n        if (cellObj && cellObj.v === \"NO\") {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * 解析单个格子\n     * @param tableParseResult\n     * @param sheet\n     * @param colKey\n     * @param rowIndex\n     * @param isNewRowOrCol 是否为新的一行或者一列\n     */\n    parseVerticalCell(\n        tableParseResult: ITableParseResult,\n        sheet: xlsx.Sheet,\n        colKey: string,\n        rowIndex: number,\n        isNewRowOrCol: boolean\n    ): void {\n        const fieldInfo = this.getVerticalTableField(tableParseResult, sheet, colKey, rowIndex);\n        if (!fieldInfo) return;\n        const cell: xlsx.CellObject = sheet[colKey + rowIndex];\n        if (isEmptyCell(cell)) {\n            return;\n        }\n\n        const transResult = this.transValue(tableParseResult, fieldInfo, cell.v);\n        if (transResult.error) {\n            Logger.log(\n                `!!!!!!!!!!!!!!!!!![-----解析错误-----]!!!!!!!!!!!!!!!!!!!!!!!!!\\n` +\n                    `[sheetName|分表名]=> ${tableParseResult.curSheetName}\\n` +\n                    `[row|行]=> ${rowIndex}\\n` +\n                    `[col|列]=> ${colKey}\\n` +\n                    `[field|字段]=> ${fieldInfo.originFieldName}\\n` +\n                    `[type|类型]=> ${fieldInfo.originType}\\n` +\n                    `[error|错误]=> ${\n                        typeof transResult.error === \"string\" ? transResult.error : transResult.error.message\n                    }\\n`,\n                \"error\"\n            );\n            // Logger.log(transResult.error, \"error\");\n        }\n        const transedValue = transResult.value;\n        let mainKeyFieldName: string = tableParseResult.mainKeyFieldName;\n        if (!mainKeyFieldName) {\n            //第一个字段就是主键\n            mainKeyFieldName = fieldInfo.fieldName;\n            tableParseResult.mainKeyFieldName = fieldInfo.fieldName;\n            tableParseResult.tableObj = {};\n        }\n        let rowOrColObj: any = tableParseResult.curRowOrColObj;\n        if (isNewRowOrCol) {\n            //新的一行\n            rowOrColObj = {};\n            tableParseResult.curRowOrColObj = tableParseResult.tableObj[transedValue] = rowOrColObj;\n        }\n\n        if (fieldInfo.isMutiColObj) {\n            let subObj = rowOrColObj[fieldInfo.fieldName];\n            if (!subObj) {\n                subObj = {};\n                rowOrColObj[fieldInfo.fieldName] = subObj;\n            }\n            subObj[fieldInfo.subFieldName] = transedValue;\n        } else {\n            rowOrColObj[fieldInfo.fieldName] = transedValue;\n        }\n    }\n    /**\n     * 解析横向单个格子\n     * @param tableParseResult\n     * @param sheet\n     * @param colKey\n     * @param rowIndex\n     * @param isNewRowOrCol 是否为新的一行或者一列\n     */\n    parseHorizontalCell(\n        tableParseResult: ITableParseResult,\n        sheet: xlsx.Sheet,\n        colKey: string,\n        rowIndex: number,\n        isNewRowOrCol: boolean\n    ): void {\n        const fieldInfo = this.getHorizontalTableField(tableParseResult, sheet, colKey, rowIndex);\n        if (!fieldInfo) return;\n        const cell: xlsx.CellObject = sheet[colKey + rowIndex];\n        if (isEmptyCell(cell)) {\n            return;\n        }\n        const transResult = this.transValue(tableParseResult, fieldInfo, cell.v);\n        if (transResult.error) {\n            Logger.log(\n                `!!!!!!!!!!!!!!!!!![-----ParseError|解析错误-----]!!!!!!!!!!!!!!!!!!!!!!!!!\\n` +\n                    `[sheetName|分表名]=> ${tableParseResult.curSheetName}\\n` +\n                    `[row|行]=> ${rowIndex}\\n` +\n                    `[col|列]=> ${colKey}\\n` +\n                    `[field|字段]=> ${fieldInfo.originFieldName}\\n` +\n                    `[type|类型]=> ${fieldInfo.originType}\\n` +\n                    `[error|错误]=> ${\n                        typeof transResult.error === \"string\" ? transResult.error : transResult.error.message\n                    }\\n` +\n                    `!!!!!!!!!!!!!!!!!![-----ParseError|解析错误-----]!!!!!!!!!!!!!!!!!!!!!!!!!\\n`,\n\n                \"error\"\n            );\n        }\n        const transedValue = transResult.value;\n        if (!tableParseResult.tableObj) {\n            tableParseResult.tableObj = {};\n        }\n        if (fieldInfo.isMutiColObj) {\n            let subObj = tableParseResult.tableObj[fieldInfo.fieldName];\n            if (!subObj) {\n                subObj = {};\n                tableParseResult.tableObj[fieldInfo.fieldName] = subObj;\n            }\n            subObj[fieldInfo.subFieldName] = transedValue;\n        } else {\n            tableParseResult.tableObj[fieldInfo.fieldName] = transedValue;\n        }\n    }\n    /**\n     * 解析出字段对象\n     * @param tableParseResult\n     * @param sheet\n     * @param colKey\n     * @param rowIndex\n     */\n    getVerticalTableField(\n        tableParseResult: ITableParseResult,\n        sheet: xlsx.Sheet,\n        colKey: string,\n        rowIndex: number\n    ): ITableField {\n        const tableDefine = tableParseResult.tableDefine;\n        let tableFiledMap = tableParseResult.filedMap;\n        if (!tableFiledMap) {\n            tableFiledMap = {};\n            tableParseResult.filedMap = tableFiledMap;\n        }\n        const verticalFieldDefine = tableDefine.verticalFieldDefine;\n        const filedCell = sheet[colKey + verticalFieldDefine.fieldRow];\n        let originFieldName: string;\n        if (!isEmptyCell(filedCell)) {\n            originFieldName = filedCell.v as string;\n        }\n        if (!originFieldName) return null;\n        let field: ITableField = {} as any;\n        //缓存\n        if (tableFiledMap[originFieldName] !== undefined) {\n            return tableFiledMap[originFieldName];\n        }\n        //注释\n        const textCell: xlsx.CellObject = sheet[colKey + verticalFieldDefine.textRow];\n        if (!isEmptyCell(textCell)) {\n            field.text = textCell.v as string;\n        }\n        //类型\n        let isObjType: boolean = false;\n        const typeCell = sheet[colKey + verticalFieldDefine.typeRow];\n\n        if (isEmptyCell(typeCell)) {\n            return null;\n        } else {\n            field.originType = typeCell.v as string;\n            if (field.originType.includes(\"mf:\")) {\n                const typeStrs = field.originType.split(\":\");\n                if (typeStrs.length < 3) {\n                    return null;\n                }\n                field.type = typeStrs[2];\n                isObjType = true;\n            } else {\n                field.type = field.originType;\n            }\n        }\n        field.isMutiColObj = isObjType;\n        //字段名\n        field.originFieldName = originFieldName;\n        if (isObjType) {\n            const fieldStrs = field.originFieldName.split(\":\");\n            if (fieldStrs.length < 2) {\n                return null;\n            }\n            field.fieldName = fieldStrs[0];\n            field.subFieldName = fieldStrs[1];\n        } else {\n            field.fieldName = field.originFieldName;\n        }\n\n        tableFiledMap[colKey] = field;\n        return field;\n    }\n    getHorizontalTableField(\n        tableParseResult: ITableParseResult,\n        sheet: xlsx.Sheet,\n        colKey: string,\n        rowIndex: number\n    ): ITableField {\n        const tableDefine = tableParseResult.tableDefine;\n        let tableFiledMap = tableParseResult.filedMap;\n        if (!tableFiledMap) {\n            tableFiledMap = {};\n            tableParseResult.filedMap = tableFiledMap;\n        }\n        const hFieldDefine = tableDefine.horizontalFieldDefine;\n        const fieldNameCell: xlsx.CellObject = sheet[hFieldDefine.fieldCol + rowIndex];\n        let originFieldName: string;\n        if (!isEmptyCell(fieldNameCell)) {\n            originFieldName = fieldNameCell.v as string;\n        }\n        if (!originFieldName) return null;\n        if (tableFiledMap[originFieldName] !== undefined) {\n            return tableFiledMap[originFieldName];\n        }\n        let field: ITableField = {} as any;\n\n        const textCell: xlsx.CellObject = sheet[hFieldDefine.textCol + rowIndex];\n        //注释\n        if (!isEmptyCell(textCell)) {\n            field.text = textCell.v as string;\n        }\n        let isObjType: boolean = false;\n        //类型\n        const typeCell: xlsx.CellObject = sheet[hFieldDefine.typeCol + rowIndex];\n\n        if (isEmptyCell(typeCell)) {\n            return null;\n        } else {\n            //处理类型\n            field.originType = typeCell.v as string;\n            if (field.originType.includes(\"mf:\")) {\n                const typeStrs = field.originType.split(\":\");\n                if (typeStrs.length < 3) {\n                    return null;\n                }\n                field.type = typeStrs[2];\n                isObjType = true;\n            } else {\n                field.type = field.originType;\n            }\n        }\n        field.isMutiColObj = isObjType;\n        field.originFieldName = originFieldName;\n        if (isObjType) {\n            const fieldStrs = field.originFieldName.split(\":\");\n            if (fieldStrs.length < 2) {\n                return null;\n            }\n            field.fieldName = fieldStrs[0];\n            field.subFieldName = fieldStrs[1];\n        } else {\n            field.fieldName = field.originFieldName;\n        }\n        tableFiledMap[originFieldName] = field;\n        return field;\n    }\n    /**\n     * 检查列是否需要解析\n     * @param tableDefine\n     * @param sheet\n     * @param colKey\n     */\n    checkColNeedParse(tableDefine: ITableDefine, sheet: xlsx.Sheet, colKey: string): boolean {\n        // 如果类型或者则不需要解析\n        if (tableDefine.tableType === TableType.vertical) {\n            const verticalFieldDefine = tableDefine.verticalFieldDefine;\n            const typeCellObj: xlsx.CellObject = sheet[colKey + verticalFieldDefine.typeRow];\n            const fieldCellObj: xlsx.CellObject = sheet[colKey + verticalFieldDefine.fieldRow];\n            if (isEmptyCell(typeCellObj) || isEmptyCell(fieldCellObj)) {\n                return false;\n            } else {\n                return true;\n            }\n        } else if (tableDefine.tableType === TableType.horizontal) {\n            const cellObj: xlsx.CellObject = sheet[colKey + 1];\n            if (isEmptyCell(cellObj)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n    }\n    /**\n     * 转换表格的值\n     * @param parseResult\n     * @param filedItem\n     * @param cellValue\n     */\n    public transValue(parseResult: ITableParseResult, filedItem: ITableField, cellValue: any): ITransValueResult {\n        let transResult: ITransValueResult;\n\n        let transFunc = this._valueTransFuncMap[filedItem.type];\n        if (!transFunc) {\n            transFunc = this._valueTransFuncMap[\"json\"];\n        }\n        transResult = transFunc(filedItem, cellValue);\n        return transResult;\n    }\n\n    /**\n     * 解析配置表文件\n     * @param parseConfig 解析配置\n     * @param fileInfo 文件信息\n     * @param parseResult 解析结果\n     */\n    public parseTableFile(\n        parseConfig: ITableConvertConfig,\n        fileInfo: IFileInfo,\n        parseResult: ITableParseResult\n    ): ITableParseResult {\n        const workbook = readTableFile(fileInfo);\n        if (!workbook.SheetNames.length) return;\n\n        const sheetNames = workbook.SheetNames;\n        const tableDefine: ITableDefine = this.getTableDefine(fileInfo, workbook);\n        for (let i = 0; i < sheetNames.length; i++) {}\n        if (!tableDefine) return null;\n        let sheetName: string;\n        let sheet: xlsx.Sheet;\n        const isSheetRowEnd = this.isSheetRowEnd.bind(null, tableDefine);\n        const isSheetColEnd = this.isSheetColEnd.bind(null, tableDefine);\n        const isSkipSheetRow = (sheet: xlsx.Sheet, rowIndex: number) => {\n            return !this.checkRowNeedParse(tableDefine, sheet, rowIndex);\n        };\n        const isSkipSheetCol = (sheet: xlsx.Sheet, colKey: string) => {\n            return !this.checkColNeedParse(tableDefine, sheet, colKey);\n        };\n        let cellObj: xlsx.CellObject;\n        parseResult.tableDefine = tableDefine;\n        Logger.log(`[parseTable|解析文件]=> ${fileInfo.filePath}`);\n        for (let i = 0; i < sheetNames.length; i++) {\n            sheetName = sheetNames[i];\n            sheet = workbook.Sheets[sheetName];\n            if (!this.checkSheetCanParse(tableDefine, sheet, sheetName)) {\n                continue;\n            }\n            parseResult.curSheetName = sheetName;\n            Logger.log(`|=[parseSheet|解析分表]=> ${sheetName}`);\n            if (tableDefine.tableType === TableType.vertical) {\n                let lastRowIndex: number;\n\n                verticalForEachSheet(\n                    sheet,\n                    tableDefine.startRow,\n                    tableDefine.startCol,\n                    (sheet, colKey: string, rowIndex: number) => {\n                        let isNewRowOrCol = false;\n                        if (lastRowIndex !== rowIndex) {\n                            lastRowIndex = rowIndex;\n                            isNewRowOrCol = true;\n                        }\n                        cellObj = sheet[colKey + rowIndex];\n                        if (!isEmptyCell(cellObj)) {\n                            this.parseVerticalCell(parseResult, sheet, colKey, rowIndex, isNewRowOrCol);\n                        }\n                    },\n                    isSheetRowEnd,\n                    isSheetColEnd,\n                    isSkipSheetRow,\n                    isSkipSheetCol\n                );\n            } else if (tableDefine.tableType === TableType.horizontal) {\n                let lastColKey: string;\n\n                horizontalForEachSheet(\n                    sheet,\n                    tableDefine.startRow,\n                    tableDefine.startCol,\n                    (sheet, colKey: string, rowIndex: number) => {\n                        let isNewRowOrCol = false;\n                        if (lastColKey !== colKey) {\n                            lastColKey = colKey;\n                            isNewRowOrCol = true;\n                        }\n\n                        cellObj = sheet[colKey + rowIndex];\n                        if (!isEmptyCell(cellObj)) {\n                            this.parseHorizontalCell(parseResult, sheet, colKey, rowIndex, isNewRowOrCol);\n                        }\n                    },\n                    isSheetRowEnd,\n                    isSheetColEnd,\n                    isSkipSheetRow,\n                    isSkipSheetCol\n                );\n            }\n        }\n\n        return parseResult as any;\n    }\n}\n","import { DefaultOutPutTransformer } from \"./default-output-transformer\";\nimport { Logger } from \"./loger\";\n\nexport class DefaultConvertHook implements IConvertHook {\n    onStart?(context: IConvertContext, cb: VoidFunction): void {\n        Logger.systemLog(`convert-hook onStart`);\n        cb();\n    }\n    onParseBefore?(context: IConvertContext, cb: VoidFunction): void {\n        Logger.systemLog(`convert-hook onParseBefore`);\n        cb();\n    }\n    onParseAfter?(context: IConvertContext, cb: VoidFunction): void {\n        let transformer: IOutPutTransformer = context.outputTransformer;\n\n        transformer.transform(context, cb);\n    }\n    onWriteFileEnd(context: IConvertContext): void {\n        Logger.systemLog(`convert-hook onWriteFileEnd 写入结束`);\n    }\n}\n","import * as path from \"path\";\nimport { TableType } from \"./default-parse-handler\";\nimport { deflateSync } from \"zlib\";\nimport { osEol } from \"./get-os-eol\";\ndeclare global {\n    /**\n     * 输出配置\n     */\n    interface IOutputConfig {\n        /**单个配置表json输出目录路径 */\n        clientSingleTableJsonDir?: string;\n        /**合并配置表json文件路径(包含文件名,比如 ./out/bundle.json) */\n        clientBundleJsonOutPath?: string;\n        /**是否格式化合并后的json，默认不 */\n        isFormatBundleJson?: boolean;\n        /**是否生成声明文件，默认不输出 */\n        isGenDts?: boolean;\n        /**声明文件输出目录(每个配置表一个声明)，默认不输出 */\n        clientDtsOutDir?: string;\n        /**是否合并所有声明为一个文件,默认true */\n        isBundleDts?: boolean;\n        /**合并后的声明文件名,如果没有则默认为tableMap */\n        bundleDtsFileName?: string;\n        /**是否将json格式压缩,默认否,减少json字段名字符,效果较小 */\n        isCompress?: boolean;\n        /**是否Zip压缩,使用zlib */\n        isZip?: boolean;\n    }\n}\n\n/**类型字符串映射字典 */\nconst typeStrMap = { int: \"number\", json: \"any\", \"[int]\": \"number[]\", \"[string]\": \"string[]\" };\nexport class DefaultOutPutTransformer {\n    /**\n     * 转换\n     * @param context\n     * @returns\n     */\n    transform(context: IConvertContext, cb: VoidFunction) {\n        const convertConfig = context.convertConfig;\n        const parseResultMap = context.parseResultMap;\n        let outputConfig: IOutputConfig = convertConfig.outputConfig;\n        if (!outputConfig) {\n            console.error(`parseConfig.outputConfig is undefind`);\n            return;\n        }\n\n        let tableObjMap: { [key: string]: any } = {};\n        let outputFileMap: OutPutFileMap = {};\n        let tableTypeMapDtsStr = \"\";\n        let tableTypeDtsStrs = \"\";\n        let parseResult: ITableParseResult;\n        let tableName: string;\n        let tableObj: any;\n        let objTypeTableMap: { [key: string]: boolean } = {};\n        for (let filePath in parseResultMap) {\n            parseResult = parseResultMap[filePath];\n            if (!parseResult.tableDefine) continue;\n\n            tableName = parseResult.tableDefine.tableName;\n\n            //合并多个同名表\n            tableObj = tableObjMap[tableName];\n            if (tableObj) {\n                tableObj = Object.assign(tableObj, parseResult.tableObj);\n            } else {\n                tableObj = parseResult.tableObj;\n            }\n            tableObjMap[tableName] = tableObj;\n\n            if (outputConfig.isGenDts && objTypeTableMap[tableName] === undefined) {\n                objTypeTableMap[tableName] = parseResult.tableDefine.tableType === TableType.horizontal;\n                if (parseResult.tableDefine.tableType === TableType.horizontal) {\n                    tableTypeMapDtsStr += \"\\treadonly \" + tableName + \"?: \" + `IT_${tableName};` + osEol;\n                } else {\n                    tableTypeMapDtsStr += this._getOneTableTypeStr(tableName);\n                }\n                //输出单个文件\n                if (outputConfig.isBundleDts === undefined) outputConfig.isBundleDts = true;\n                if (!outputConfig.isBundleDts) {\n                    this._addSingleTableDtsOutputFile(outputConfig, parseResult, outputFileMap);\n                } else {\n                    tableTypeDtsStrs += this._getSingleTableDts(parseResult);\n                }\n            }\n\n            //生成单个表json\n            if (outputConfig.clientSingleTableJsonDir) {\n                this._addSingleTableJsonOutputFile(outputConfig, parseResult, outputFileMap);\n            }\n        }\n        if (outputConfig.isGenDts) {\n            //输出声明文件\n            let itBaseStr = \"interface ITBase<T> { [key:string]:T}\" + osEol;\n\n            tableTypeMapDtsStr = itBaseStr + \"interface IT_TableMap {\" + osEol + tableTypeMapDtsStr + \"}\" + osEol;\n\n            if (outputConfig.isBundleDts) {\n                //合成一个文件\n                const dtsFileName = outputConfig.bundleDtsFileName ? outputConfig.bundleDtsFileName : \"tableMap\";\n                const bundleDtsFilePath = path.join(outputConfig.clientDtsOutDir, `${dtsFileName}.d.ts`);\n                outputFileMap[bundleDtsFilePath] = {\n                    filePath: bundleDtsFilePath,\n                    data: tableTypeMapDtsStr + tableTypeDtsStrs\n                };\n            } else {\n                //拆分文件输出\n                const tableTypeMapDtsFilePath = path.join(outputConfig.clientDtsOutDir, \"tableMap.d.ts\");\n                outputFileMap[tableTypeMapDtsFilePath] = {\n                    filePath: tableTypeMapDtsFilePath,\n                    data: tableTypeMapDtsStr\n                };\n            }\n        }\n\n        //jsonBundleFile\n        if (outputConfig.clientBundleJsonOutPath) {\n            let jsonBundleFilePath = outputConfig.clientBundleJsonOutPath;\n            let outputData: any;\n            if (outputConfig.isCompress) {\n                //进行格式压缩\n                const newTableObjMap = {};\n                let tableObj: any;\n                let newTableObj: any;\n                for (let tableName in tableObjMap) {\n                    if (objTypeTableMap[tableName]) {\n                        newTableObjMap[tableName] = tableObjMap[tableName];\n                        continue;\n                    }\n                    tableObj = tableObjMap[tableName];\n                    newTableObj = { fieldValuesMap: {} };\n                    for (let mainKey in tableObj) {\n                        if (!newTableObj.fieldNames) {\n                            newTableObj.fieldNames = Object.keys(tableObj[mainKey]);\n                        }\n                        newTableObj.fieldValuesMap[mainKey] = Object.values(tableObj[mainKey]);\n                    }\n                    newTableObjMap[tableName] = newTableObj;\n                }\n                outputData = JSON.stringify(newTableObjMap);\n            } else {\n                outputData = JSON.stringify(tableObjMap);\n            }\n            //进行base64处理\n            // if (outputConfig.bundleJsonIsEncode2Base64) {\n            //     outputData = Base64.encode(outputData);\n            //     if (outputConfig.preBase64UglyString) {\n            //         outputData = outputConfig.preBase64UglyString + outputData;\n            //     }\n            //     if (outputConfig.sufBase64UglyString) {\n            //         outputData += outputConfig.sufBase64UglyString;\n            //     }\n            // }\n            if (outputConfig.isZip) {\n                //使用zilb压缩\n                outputData = deflateSync(outputData);\n            }\n            outputFileMap[jsonBundleFilePath] = {\n                filePath: jsonBundleFilePath,\n                encoding: typeof outputData !== \"string\" ? \"binary\" : \"utf-8\",\n                data: outputData\n            };\n        }\n        if (context.outPutFileMap) {\n            for (let key in outputFileMap) {\n                context.outPutFileMap[key] = outputFileMap[key];\n            }\n        } else {\n            context.outPutFileMap = outputFileMap;\n        }\n        cb();\n    }\n    private _addSingleTableDtsOutputFile(\n        config: IOutputConfig,\n        parseResult: ITableParseResult,\n        outputFileMap: OutPutFileMap\n    ): void {\n        //如果值没有就不输出类型信息了\n        if (!parseResult.tableObj) return;\n        let dtsFilePath: string = path.join(config.clientDtsOutDir, `${parseResult.tableDefine.tableName}.d.ts`);\n\n        if (!outputFileMap[dtsFilePath]) {\n            //\n            const dtsStr = this._getSingleTableDts(parseResult);\n            if (dtsStr) {\n                outputFileMap[dtsFilePath] = { filePath: dtsFilePath, data: dtsStr } as any;\n            }\n        }\n    }\n    /**\n     * 解析出单个配置表类型数据\n     * @param parseResult\n     */\n    private _getSingleTableDts(parseResult: ITableParseResult): string {\n        const tableName = parseResult.tableDefine.tableName;\n\n        const colKeyTableFieldMap: ColKeyTableFieldMap = parseResult.filedMap;\n        let itemInterface = \"interface IT_\" + tableName + \" {\" + osEol;\n        let tableField: ITableField;\n        let typeStr: string;\n        let objTypeStrMap: { [key: string]: string } = {};\n\n        for (let colKey in colKeyTableFieldMap) {\n            tableField = colKeyTableFieldMap[colKey];\n            if (!tableField) continue;\n            if (!tableField.isMutiColObj) {\n                //注释行\n                itemInterface += \"\\t/** \" + tableField.text + \" */\" + osEol;\n                //字段类型声明行\n                itemInterface +=\n                    \"\\treadonly \" +\n                    tableField.fieldName +\n                    \"?: \" +\n                    (typeStrMap[tableField.type] ? typeStrMap[tableField.type] : tableField.type) +\n                    \";\" +\n                    osEol;\n            } else {\n                const objFieldKey = tableField.fieldName;\n                if (!objTypeStrMap[objFieldKey]) {\n                    objTypeStrMap[objFieldKey] = \"\";\n                }\n\n                //注释行\n                objTypeStrMap[objFieldKey] += \"\\t\\t/** \" + tableField.text + \" */\" + osEol;\n\n                //字段类型声明行\n                objTypeStrMap[objFieldKey] +=\n                    \"\\t\\treadonly \" +\n                    tableField.subFieldName +\n                    \"?: \" +\n                    (typeStrMap[tableField.type] ? typeStrMap[tableField.type] : tableField.type) +\n                    \";\" +\n                    osEol;\n            }\n        }\n        //第二层对象\n        for (let objFieldKey in objTypeStrMap) {\n            //字段类型声明行\n            itemInterface += \"\\treadonly \" + objFieldKey + \"?: {\" + osEol + objTypeStrMap[objFieldKey];\n            itemInterface += \"\\t}\" + osEol;\n        }\n        itemInterface += \"}\" + osEol;\n\n        return itemInterface;\n    }\n    /**\n     * 添加单独导出配置表json文件\n     * @param config\n     * @param parseResult\n     * @param outputFileMap\n     */\n    private _addSingleTableJsonOutputFile(\n        config: IOutputConfig,\n        parseResult: ITableParseResult,\n        outputFileMap: OutPutFileMap\n    ) {\n        const tableObj = parseResult.tableObj;\n        if (!tableObj) return;\n        const tableName = parseResult.tableDefine.tableName;\n        let singleJsonFilePath = path.join(config.clientSingleTableJsonDir, `${tableName}.json`);\n        let singleJsonData = JSON.stringify(tableObj, null, \"\\t\");\n\n        let singleOutputFileInfo = outputFileMap[singleJsonFilePath];\n        if (singleOutputFileInfo) {\n            singleOutputFileInfo.data = singleJsonData;\n        } else {\n            singleOutputFileInfo = {\n                filePath: singleJsonFilePath,\n                data: singleJsonData\n            };\n            outputFileMap[singleJsonFilePath] = singleOutputFileInfo;\n        }\n    }\n    private _getOneTableTypeStr(tableName: string): string {\n        return \"\\treadonly \" + tableName + \"?: \" + \"ITBase<\" + \"IT_\" + tableName + \">;\" + osEol;\n    }\n}\n","export function doParse(\n    parseConfig: ITableConvertConfig,\n    fileInfos: IFileInfo[],\n    parseResultMap: TableParseResultMap,\n    parseHandler: ITableParseHandler\n) {\n    let parseResult;\n    for (let i = fileInfos.length - 1; i >= 0; i--) {\n        parseResult = parseResultMap[fileInfos[i].filePath];\n        if (!parseResult) {\n            parseResult = { filePath: fileInfos[i].filePath };\n        }\n        if (!parseResult.tableObj) {\n            parseResult = parseHandler.parseTableFile(parseConfig, fileInfos[i], parseResult);\n        }\n        if (parseResult) {\n            parseResultMap[fileInfos[i].filePath] = parseResult;\n        }\n    }\n}\n","import * as fs from \"fs-extra\";\nimport * as path from \"path\";\nimport * as crypto from \"crypto\";\nimport { Logger } from \"./loger\";\n\ndeclare global {\n    interface IOutPutFileInfo {\n        filePath: string;\n        /**写入编码，字符串默认utf8 */\n        encoding?: BufferEncoding;\n        /**是否删除 */\n        isDelete?: boolean;\n        data?: any;\n    }\n}\n/**\n * 遍历文件\n * @param dirPath 文件夹路径\n * @param eachCallback 遍历回调 (filePath: string) => void\n */\nexport function forEachFile(fileOrDirPath: string, eachCallback?: (filePath: string) => void) {\n    if (fs.statSync(fileOrDirPath).isDirectory()) {\n        const fileNames = fs.readdirSync(fileOrDirPath);\n        let childFilePath: string;\n        for (var i = 0; i < fileNames.length; i++) {\n            childFilePath = path.join(fileOrDirPath, fileNames[i]);\n            forEachFile(childFilePath, eachCallback);\n        }\n    } else {\n        eachCallback(fileOrDirPath);\n    }\n}\n/**\n * 批量写入和删除文件\n * @param outputFileInfos 需要写入的文件信息数组\n * @param onProgress 进度变化回调\n * @param complete 完成回调\n */\nexport function writeOrDeleteOutPutFiles(\n    outputFileInfos: IOutPutFileInfo[],\n    onProgress?: (filePath: string, total: number, now: number, isOk: boolean) => void,\n    complete?: (total: number) => void\n) {\n    let fileInfo: IOutPutFileInfo;\n    const total = outputFileInfos.length;\n    if (outputFileInfos && total) {\n        let now = 0;\n        const onWriteEnd = (err) => {\n            if (err) {\n                Logger.log(err, \"error\");\n            }\n            now++;\n            onProgress && onProgress(outputFileInfos[now - 1].filePath, total, now, !err);\n            if (now >= total) {\n                complete && complete(total);\n            }\n        };\n        for (let i = outputFileInfos.length - 1; i >= 0; i--) {\n            fileInfo = outputFileInfos[i];\n\n            if (fileInfo.isDelete && fs.existsSync(fileInfo.filePath)) {\n                fs.unlinkSync(fileInfo.filePath);\n            } else {\n                if (fs.existsSync(fileInfo.filePath) && fs.statSync(fileInfo.filePath).isDirectory()) {\n                    Logger.log(`路径为文件夹:${fileInfo.filePath}`, \"error\");\n                    continue;\n                }\n\n                if (!fileInfo.encoding && typeof fileInfo.data === \"string\") {\n                    fileInfo.encoding = \"utf8\";\n                }\n                fs.ensureFileSync(fileInfo.filePath);\n                fs.writeFile(\n                    fileInfo.filePath,\n                    fileInfo.data,\n                    fileInfo.encoding ? { encoding: fileInfo.encoding } : undefined,\n                    onWriteEnd\n                );\n            }\n        }\n    }\n}\n/**\n * 获取变化过的文件数组\n * @param dir 目标目录\n * @param cacheFilePath 缓存文件绝对路径\n * @param eachCallback 遍历回调\n * @returns 返回缓存文件路径\n */\nexport function forEachChangedFile(\n    dir: string,\n    cacheFilePath?: string,\n    eachCallback?: (filePath: string, isDelete?: boolean) => void\n) {\n    const gcfCache = getCacheData(cacheFilePath);\n    const oldFilePaths = Object.keys(gcfCache);\n    let oldFilePathIndex: number;\n    forEachFile(dir, (filePath) => {\n        var md5str = getFileMd5Sync(filePath);\n        if (!gcfCache[filePath] || (gcfCache[filePath] && gcfCache[filePath] !== md5str)) {\n            gcfCache[filePath] = md5str;\n            eachCallback(filePath, false);\n        }\n        oldFilePathIndex = oldFilePaths.indexOf(filePath);\n        if (oldFilePathIndex > -1) {\n            const endFilePath = oldFilePaths[oldFilePaths.length - 1];\n            oldFilePaths[oldFilePathIndex] = endFilePath;\n            oldFilePaths.pop();\n        }\n    });\n    for (let i = 0; i < oldFilePaths.length; i++) {\n        delete gcfCache[oldFilePaths[i]];\n        eachCallback(oldFilePaths[i], true);\n    }\n    fs.writeFileSync(cacheFilePath, JSON.stringify(gcfCache), { encoding: \"utf-8\" });\n}\n/**\n * 写入缓存数据\n * @param cacheFilePath\n * @param cacheData\n */\nexport function writeCacheData(cacheFilePath: string, cacheData: any) {\n    if (!cacheFilePath) {\n        Logger.log(`cacheFilePath is null`, \"error\");\n        return;\n    }\n    fs.writeFileSync(cacheFilePath, JSON.stringify(cacheData), { encoding: \"utf-8\" });\n}\n/**\n * 读取缓存数据\n * @param cacheFilePath\n */\nexport function getCacheData(cacheFilePath: string): any {\n    if (!cacheFilePath) {\n        Logger.log(`cacheFilePath is null`, \"error\");\n        return;\n    }\n    if (!fs.existsSync(cacheFilePath)) {\n        fs.ensureFileSync(cacheFilePath);\n        fs.writeFileSync(cacheFilePath, \"{}\", { encoding: \"utf-8\" });\n    }\n    const gcfCacheFile = fs.readFileSync(cacheFilePath, \"utf-8\");\n    const gcfCache = JSON.parse(gcfCacheFile);\n    return gcfCache;\n}\n/**\n * 获取文件md5 (同步)\n * @param filePath\n */\nexport function getFileMd5Sync(filePath: string): string {\n    const file = fs.readFileSync(filePath, \"utf-8\");\n    var md5um = crypto.createHash(\"md5\");\n    md5um.update(file);\n    return md5um.digest(\"hex\");\n}\n/**\n * 获取文件 md5\n * @param filePath\n */\nexport async function getFileMd5(filePath: string) {\n    return getFileMd5Sync(filePath);\n}\n","import * as path from \"path\";\nimport * as fs from \"fs-extra\";\nimport * as mmatch from \"micromatch\";\nimport { forEachFile, getCacheData, getFileMd5Sync, writeCacheData, writeOrDeleteOutPutFiles } from \"./file-utils\";\nimport { Worker } from \"worker_threads\";\nimport { doParse } from \"./do-parse\";\nimport { DefaultParseHandler } from \"./default-parse-handler\";\nimport { Logger } from \"./loger\";\nimport { DefaultConvertHook } from \"./default-convert-hook\";\nimport { DefaultOutPutTransformer } from \"./default-output-transformer\";\nconst defaultDir = \".excel2all\";\nconst cacheFileName = \".e2aprmc\";\nconst logFileName = \"excel2all.log\";\n/**\n * 转换\n * @param converConfig 解析配置\n */\nexport async function convert(converConfig: ITableConvertConfig) {\n    if (!converConfig.projRoot) {\n        converConfig.projRoot = process.cwd();\n    }\n    let convertHook: IConvertHook;\n    if (converConfig.customConvertHookPath) {\n        convertHook = require(converConfig.customConvertHookPath);\n    } else {\n        convertHook = new DefaultConvertHook();\n    }\n    let outputTransformer: IOutPutTransformer;\n    if (converConfig.customOutPutTransformerPath) {\n        outputTransformer = require(converConfig.customOutPutTransformerPath);\n    } else {\n        outputTransformer = new DefaultOutPutTransformer();\n    }\n    const tableFileDir = converConfig.tableFileDir;\n    if (!tableFileDir) {\n        Logger.log(`配置表目录：tableFileDir为空`, \"error\");\n        return;\n    }\n    if (!fs.existsSync(tableFileDir)) {\n        Logger.log(`配置表文件夹不存在：${tableFileDir}`, \"error\");\n        return;\n    }\n    const defaultPattern = [\"**/*.{xlsx,csv}\", \"!**/~$*.*\", \"!**/~.*.*\"];\n    if (!converConfig.pattern) {\n        converConfig.pattern = defaultPattern;\n    }\n    if (converConfig.useMultiThread && isNaN(converConfig.threadParseFileMaxNum)) {\n        converConfig.threadParseFileMaxNum = 5;\n    }\n    Logger.init(converConfig);\n    const context: IConvertContext = {\n        convertConfig: converConfig,\n        outputTransformer: outputTransformer\n    } as any;\n    //开始\n    await new Promise<void>((res) => {\n        convertHook.onStart(context, res);\n    });\n\n    let changedFileInfos: IFileInfo[] = [];\n    let deleteFileInfos: IFileInfo[] = [];\n    const getFileInfo = (filePath: string) => {\n        const filePathParse = path.parse(filePath);\n        const fileInfo: IFileInfo = {\n            filePath: filePath,\n            fileName: filePathParse.name,\n            fileExtName: filePathParse.ext,\n            isDelete: false\n        };\n        return fileInfo;\n    };\n    const matchPattern = converConfig.pattern;\n    const eachFileCallback = (filePath: string, isDelete?: boolean) => {\n        const fileInfo = getFileInfo(filePath);\n        let canRead: boolean;\n        if (isDelete) {\n            deleteFileInfos.push(fileInfo);\n        } else {\n            canRead = mmatch.all(fileInfo.filePath, matchPattern);\n            if (canRead) {\n                changedFileInfos.push(fileInfo);\n            }\n        }\n        return { fileInfo, canRead };\n    };\n    let parseResultMap: TableParseResultMap = {};\n\n    //缓存处理\n    let cacheFileDirPath: string = converConfig.cacheFileDirPath;\n    let parseResultMapCacheFilePath: string;\n\n    if (!converConfig.useCache) {\n        forEachFile(tableFileDir, eachFileCallback);\n    } else {\n        if (!cacheFileDirPath) cacheFileDirPath = defaultDir;\n        if (!path.isAbsolute(cacheFileDirPath)) {\n            cacheFileDirPath = path.join(converConfig.projRoot, cacheFileDirPath);\n        }\n        parseResultMapCacheFilePath = path.join(cacheFileDirPath, cacheFileName);\n        parseResultMap = getCacheData(parseResultMapCacheFilePath);\n        if (!parseResultMap) {\n            parseResultMap = {};\n        }\n        const oldFilePaths = Object.keys(parseResultMap);\n        let oldFilePathIndex: number;\n        let parseResult: ITableParseResult;\n        forEachFile(tableFileDir, (filePath) => {\n            var md5str = getFileMd5Sync(filePath);\n            parseResult = parseResultMap[filePath];\n            if (!parseResult) {\n                parseResult = {\n                    filePath: filePath\n                };\n                parseResultMap[filePath] = parseResult;\n            }\n            if (parseResult && parseResult.md5hash !== md5str) {\n                const { fileInfo, canRead } = eachFileCallback(filePath, false);\n                if (canRead) {\n                    parseResult.md5hash = md5str;\n                }\n            }\n            oldFilePathIndex = oldFilePaths.indexOf(filePath);\n            if (oldFilePathIndex > -1) {\n                const endFilePath = oldFilePaths[oldFilePaths.length - 1];\n                oldFilePaths[oldFilePathIndex] = endFilePath;\n                oldFilePaths.pop();\n            }\n        });\n        for (let i = 0; i < oldFilePaths.length; i++) {\n            delete parseResultMap[oldFilePaths[i]];\n            eachFileCallback(oldFilePaths[i], true);\n        }\n    }\n\n    let parseHandler: ITableParseHandler;\n    if (converConfig.customParseHandlerPath) {\n        parseHandler = require(converConfig.customParseHandlerPath);\n        if (!parseHandler || typeof parseHandler.parseTableFile !== \"function\") {\n            console.error(`自定义解析实现错误:${converConfig.customParseHandlerPath}`);\n            return;\n        }\n    } else {\n        parseHandler = new DefaultParseHandler();\n    }\n    //解析开始之前\n    context.parseResultMap = parseResultMap;\n    context.deleteFileInfos = deleteFileInfos;\n    context.changedFileInfos = changedFileInfos;\n    await new Promise<void>((res) => {\n        convertHook.onParseBefore(context, res);\n    });\n\n    if (changedFileInfos.length > converConfig.threadParseFileMaxNum && converConfig.useMultiThread) {\n        let logStr: string = \"\";\n        const count = Math.floor(changedFileInfos.length / converConfig.threadParseFileMaxNum) + 1;\n        let worker: Worker;\n        let subFileInfos: IFileInfo[];\n        let workerMap: { [key: number]: Worker } = {};\n        let completeCount: number = 0;\n        const t1 = new Date().getTime();\n        const onWorkerParseEnd = (data: IWorkDoResult) => {\n            Logger.log(`----------------线程结束:${data.threadId}-----------------`);\n            const parsedMap = data.parseResultMap;\n            for (let key in parsedMap) {\n                if (!parseResultMap[key].tableDefine) {\n                    parseResultMap[key] = parsedMap[key];\n                }\n            }\n            completeCount++;\n            logStr += data.logStr + Logger.logStr;\n            if (!context.hasError) {\n                context.hasError = Logger.hasError;\n            }\n            if (completeCount >= count) {\n                const t2 = new Date().getTime();\n                Logger.log(`[多线程导表时间]:${t2 - t1}`);\n                onParseEnd(context, parseResultMapCacheFilePath, convertHook, logStr);\n            }\n        };\n        for (let i = 0; i < count; i++) {\n            subFileInfos = changedFileInfos.splice(0, converConfig.threadParseFileMaxNum);\n            Logger.log(`----------------线程开始:${i}-----------------`);\n            worker = new Worker(path.join(path.dirname(__filename), \"../../../worker_scripts/worker.js\"), {\n                workerData: {\n                    threadId: i,\n                    fileInfos: subFileInfos,\n                    parseResultMap: parseResultMap,\n                    convertConfig: converConfig\n                } as IWorkerShareData\n            });\n            workerMap[i] = worker;\n            worker.on(\"message\", onWorkerParseEnd);\n        }\n    } else {\n        const t1 = new Date().getTime();\n\n        doParse(converConfig, changedFileInfos, parseResultMap, parseHandler);\n        const t2 = new Date().getTime();\n        Logger.systemLog(`[单线程导表时间]:${t2 - t1}`);\n        context.hasError = Logger.hasError;\n        onParseEnd(context, parseResultMapCacheFilePath, convertHook);\n    }\n}\n/**\n * 解析结束\n * @param parseConfig\n * @param parseResultMapCacheFilePath\n * @param convertHook\n * @param fileInfos\n * @param deleteFileInfos\n * @param parseResultMap\n * @param logStr\n */\nasync function onParseEnd(\n    context: IConvertContext,\n    parseResultMapCacheFilePath: string,\n    convertHook: IConvertHook,\n    logStr?: string\n) {\n    const convertConfig = context.convertConfig;\n    const parseResultMap = context.parseResultMap;\n    //如果没有错误,则写入解析缓存\n    //有错误不能写入缓存，避免错误被下次解析给忽略掉\n    if (convertConfig.useCache && !context.hasError) {\n        writeCacheData(parseResultMapCacheFilePath, parseResultMap);\n    }\n    //解析结束，做导出处理\n    await new Promise<void>((res) => {\n        convertHook.onParseAfter(context, res);\n    });\n\n    if (context.outPutFileMap) {\n        const outputFileMap = context.outPutFileMap;\n        const outputFiles = Object.values(outputFileMap);\n        //写入和删除文件处理\n        Logger.systemLog(`开始写入文件:0/${outputFiles.length}`);\n\n        await new Promise<void>((res) => {\n            writeOrDeleteOutPutFiles(\n                outputFiles,\n                (filePath, total, now, isOk) => {\n                    Logger.log(`[写入文件] 进度:(${now}/${total}) 路径:${filePath}`);\n                },\n                () => {\n                    res();\n                }\n            );\n        });\n        Logger.systemLog(`写入结束~`);\n    } else {\n        Logger.systemLog(`没有可写入文件~`);\n    }\n\n    //写入日志文件\n\n    if (!logStr) {\n        logStr = Logger.logStr;\n    }\n    if (logStr.trim() !== \"\") {\n        let logFileDirPath = context.convertConfig.outputLogDirPath as string;\n        if (!logFileDirPath) logFileDirPath = defaultDir;\n        if (!path.isAbsolute(logFileDirPath)) {\n            logFileDirPath = path.join(context.convertConfig.projRoot, logFileDirPath);\n        }\n\n        const outputLogFileInfo: IOutPutFileInfo = {\n            filePath: path.join(logFileDirPath, logFileName),\n            data: logStr\n        };\n        writeOrDeleteOutPutFiles([outputLogFileInfo]);\n    }\n    //写入结束\n    convertHook.onWriteFileEnd(context);\n}\n/**\n * 测试文件匹配\n * @param converConfig\n */\nexport function testFileMatch(converConfig: ITableConvertConfig) {\n    if (!converConfig.projRoot) {\n        converConfig.projRoot = process.cwd();\n    }\n    let convertHook: IConvertHook;\n    if (converConfig.customConvertHookPath) {\n        convertHook = require(converConfig.customConvertHookPath);\n    } else {\n        convertHook = new DefaultConvertHook();\n    }\n    const tableFileDir = converConfig.tableFileDir;\n    if (!tableFileDir) {\n        Logger.log(`配置表目录：tableFileDir为空`, \"error\");\n        return;\n    }\n    if (!fs.existsSync(tableFileDir)) {\n        Logger.log(`配置表文件夹不存在：${tableFileDir}`, \"error\");\n        return;\n    }\n    const defaultPattern = [\"**/*.{xlsx,csv}\", \"!**/~$*.*\", \"!**/~.*.*\"];\n    if (!converConfig.pattern) {\n        converConfig.pattern = defaultPattern;\n    }\n    if (converConfig.useMultiThread && isNaN(converConfig.threadParseFileMaxNum)) {\n        converConfig.threadParseFileMaxNum = 5;\n    }\n    const matchPattern = converConfig.pattern;\n    const deleteFilePaths: string[] = [];\n    const changedFilePaths: string[] = [];\n    const eachFileCallback = (filePath: string, isDelete?: boolean) => {\n        let canRead: boolean;\n        if (isDelete) {\n            deleteFilePaths.push(filePath);\n        } else {\n            canRead = mmatch.all(filePath, matchPattern);\n            if (canRead) {\n                changedFilePaths.push(filePath);\n            }\n        }\n        return { canRead };\n    };\n    let cacheFileDirPath: string = converConfig.cacheFileDirPath;\n    let parseResultMapCacheFilePath: string;\n    let parseResultMap: TableParseResultMap;\n    if (!converConfig.useCache) {\n        forEachFile(tableFileDir, eachFileCallback);\n    } else {\n        if (!cacheFileDirPath) cacheFileDirPath = \".cache\";\n        if (!path.isAbsolute(cacheFileDirPath)) {\n            cacheFileDirPath = path.join(converConfig.projRoot, cacheFileDirPath);\n        }\n        parseResultMapCacheFilePath = path.join(cacheFileDirPath, \".egfprmc\");\n        parseResultMap = getCacheData(parseResultMapCacheFilePath);\n        if (!parseResultMap) {\n            parseResultMap = {};\n        }\n        const oldFilePaths = Object.keys(parseResultMap);\n        let oldFilePathIndex: number;\n        let parseResult: ITableParseResult;\n        forEachFile(tableFileDir, (filePath) => {\n            var md5str = getFileMd5Sync(filePath);\n            parseResult = parseResultMap[filePath];\n            if (!parseResult) {\n                parseResult = {\n                    filePath: filePath\n                };\n                parseResultMap[filePath] = parseResult;\n            }\n            if (parseResult && parseResult.md5hash !== md5str) {\n                const { canRead } = eachFileCallback(filePath, false);\n                if (canRead) {\n                    parseResult.md5hash = md5str;\n                }\n            }\n            oldFilePathIndex = oldFilePaths.indexOf(filePath);\n            if (oldFilePathIndex > -1) {\n                const endFilePath = oldFilePaths[oldFilePaths.length - 1];\n                oldFilePaths[oldFilePathIndex] = endFilePath;\n                oldFilePaths.pop();\n            }\n        });\n        for (let i = 0; i < oldFilePaths.length; i++) {\n            delete parseResultMap[oldFilePaths[i]];\n            eachFileCallback(oldFilePaths[i], true);\n        }\n    }\n    if (converConfig.useCache) {\n        console.log(`----【缓存模式】----`);\n    }\n    console.log(`------------------------------匹配到的文件---------------------`);\n    console.log(changedFilePaths);\n}\n"],"names":["os.platform","xlsx.readFile","TableType","path.join","deflateSync","fs.statSync","fs.readdirSync","fs.existsSync","fs.unlinkSync","fs.ensureFileSync","fs.writeFile","fs.writeFileSync","fs.readFileSync","crypto.createHash","path.parse","mmatch.all","path.isAbsolute","Worker","path.dirname"],"mappings":"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"}