{"version":3,"file":"index.mjs","sources":["../../../src/default-value-func-map.ts","../../../src/get-os-eol.ts","../../../src/loger.ts","../../../src/table-utils.ts","../../../src/default-table-parser.ts","../../../src/default-result-transformer.ts","../../../src/default-convert-hook.ts","../../../src/file-utils.ts","../../../src/convert.ts"],"sourcesContent":["export const defaultValueTransFuncMap: {\n    [key: string]: ValueTransFunc;\n} = {};\ndefaultValueTransFuncMap[\"int\"] = strToInt;\ndefaultValueTransFuncMap[\"string\"] = anyToStr;\ndefaultValueTransFuncMap[\"[int]\"] = strToIntArr;\ndefaultValueTransFuncMap[\"[string]\"] = strToStrArr;\ndefaultValueTransFuncMap[\"json\"] = strToJsonObj;\ndefaultValueTransFuncMap[\"any\"] = anyToAny;\ndefaultValueTransFuncMap[\"bool\"] = anyToBoolean;\ndefaultValueTransFuncMap[\"boolean\"] = anyToBoolean;\nfunction strToIntArr(fieldItem: ITableField, cellValue: string): ITransValueResult {\n    cellValue = (cellValue + \"\").replace(/，/g, \",\"); //为了防止策划误填，先进行转换\n    cellValue = cellValue.trim();\n    let intArr: number[];\n    const result: ITransValueResult = {};\n    if (cellValue !== \"\") {\n        try {\n            intArr = JSON.parse(cellValue);\n            result.value = intArr;\n        } catch (error) {\n            result.error = error;\n        }\n    }\n\n    return result;\n}\nfunction strToStrArr(fieldItem: ITableField, cellValue: string): ITransValueResult {\n    cellValue = (cellValue + \"\").replace(/，/g, \",\"); //为了防止策划误填，先进行转换\n    const trimCellValue = cellValue.trim();\n    let result: ITransValueResult = {};\n    let arr: string[];\n    if (trimCellValue !== \"\") {\n        try {\n            arr = JSON.parse(cellValue);\n            result.value = arr;\n        } catch (error) {\n            result.error = error;\n        }\n    }\n    return result;\n}\nfunction strToInt(fieldItem: ITableField, cellValue: string): ITransValueResult {\n    let result: ITransValueResult = {} as any;\n    if (typeof cellValue === \"string\" && cellValue.trim() !== \"\") {\n        result.value = cellValue.includes(\".\") ? parseFloat(cellValue) : (parseInt(cellValue) as any);\n    } else if (typeof cellValue === \"number\") {\n        result.value = cellValue;\n    }\n    return result;\n}\nfunction strToJsonObj(fieldItem: ITableField, cellValue: string): ITransValueResult {\n    cellValue = (cellValue + \"\").replace(/，/g, \",\"); //为了防止策划误填，先进行转换\n    cellValue = cellValue.trim();\n    let obj;\n    let error;\n    if (cellValue !== \"\") {\n        try {\n            obj = JSON.parse(cellValue);\n        } catch (err) {\n            error = err;\n            obj = cellValue;\n        }\n    }\n    return { error: error, value: obj };\n}\nfunction anyToStr(fieldItem: ITableField, cellValue: any): ITransValueResult {\n    let result: ITransValueResult = {} as any;\n    if (typeof cellValue === \"string\") {\n        const trimCellValue = cellValue.trim();\n        if (trimCellValue !== \"\") {\n            result.value = cellValue;\n        }\n    } else {\n        result.value = cellValue + \"\";\n    }\n    return result;\n}\n/**\n * 先尝试转换未对象，不行再使用原值\n * @param fieldItem\n * @param cellValue\n * @returns\n */\nfunction anyToAny(fieldItem: ITableField, cellValue: string): ITransValueResult {\n    cellValue = (cellValue + \"\").replace(/，/g, \",\"); //为了防止策划误填，先进行转换\n    const trimCellValue = cellValue.trim();\n    let obj;\n    let error;\n    if (trimCellValue !== \"\") {\n        try {\n            obj = JSON.parse(cellValue);\n        } catch (err) {\n            obj = cellValue;\n        }\n    }\n    return { error: error, value: obj };\n}\n/**\n * \n * @param fieldItem\n * @param cellValue\n * @returns\n */\nfunction anyToBoolean(fieldItem: ITableField, cellValue: string): ITransValueResult {\n    let obj;\n    let error: string;\n    if (typeof cellValue === \"boolean\") {\n\n    } else if (typeof cellValue === \"string\") {\n        if (cellValue === \"FALSE\") {\n            obj = false as any;\n        } else if (cellValue === \"TRUE\") {\n            obj = true as any;\n        } else {\n            error = `无法解析这个值：${cellValue}`;\n            obj = cellValue;\n        }\n    } else if (typeof cellValue === \"number\") {\n        if (cellValue > 0) {\n            obj = true as any\n\n        }\n        else {\n            obj = false as any;\n        }\n    } else {\n        error = `无法解析这个值：${cellValue}`;\n        obj = cellValue;\n    }\n\n    return { error: error, value: obj };\n}","import * as os from \"os\";\nconst platform = os.platform();\n/**当前系统行尾  platform === \"win32\" ? \"\\n\" : \"\\r\\n\";*/\nexport const osEol = platform === \"win32\" ? \"\\n\" : \"\\r\\n\";\n","import { osEol } from \"./get-os-eol\";\nimport * as path from \"path\";\nenum LogLevelEnum {\n    info,\n    warn,\n    error,\n    no\n}\nexport class Logger {\n    private static _enableOutPutLogFile: boolean;\n    private static _logLevel: LogLevelEnum;\n    private static _logStr: string = \"\";\n    /**\n     * 如果有输出过错误信息则为true\n     */\n    public static hasError: boolean = false;\n    public static init(convertConfig: ITableConvertConfig) {\n        const level: LogLevel = convertConfig.logLevel ? convertConfig.logLevel : \"info\";\n        this._logLevel = LogLevelEnum[level];\n        this._enableOutPutLogFile = convertConfig.outputLogDirPath === false ? false : true;\n    }\n    /**\n     * 输出日志,日志等级只是限制了控制台输出，但不限制日志记录\n     * @param message\n     * @param level\n     */\n    public static log(message: string, level: LogLevel = \"info\") {\n        if (level !== \"no\") {\n            if (this._logLevel <= LogLevelEnum[level]) {\n                switch (level) {\n                    case \"error\":\n                        console.error(message);\n                        if (!this.hasError) this.hasError = true;\n                        break;\n                    case \"info\":\n                        console.log(message);\n                        break;\n                    case \"warn\":\n                        console.warn(message);\n                        break;\n                }\n            }\n        }\n\n        if (!this._enableOutPutLogFile) return;\n        this._logStr += message + osEol;\n    }\n    /**\n     * 系统日志输出\n     * @param args\n     */\n    public static systemLog(message: string) {\n        console.log(message);\n        if (!this._enableOutPutLogFile) return;\n        this._logStr += message + osEol;\n    }\n    /**\n     * 返回日志数据并清空\n     */\n    public static get logStr(): string {\n        if (!this._enableOutPutLogFile) return null;\n        const logStr = this._logStr;\n        this._logStr = \"\"; //清空\n        return logStr;\n    }\n}\n","import * as xlsx from \"xlsx\";\n/**\n * 是否为空表格格子\n * @param cell\n */\nexport function isEmptyCell(cell: xlsx.CellObject) {\n    if (cell && cell.v !== undefined) {\n        if (typeof cell.v === \"string\") {\n            return cell.v === \"\";\n        } else if (typeof cell.v === \"number\") {\n            return isNaN(cell.v);\n        } else {\n            return false;\n        }\n    } else {\n        return true;\n    }\n}\n/**\n * 字母Z的编码\n */\nexport const ZCharCode = 90;\n/**\n * 字母A的编码\n *\n */\nexport const ACharCode = 65;\n/**\n * 根据当前列的charCodes获取下一列Key\n * @param charCodes\n */\nexport function getNextColKey(charCodes: number[]): string {\n    let isAdd: boolean;\n    for (let i = charCodes.length - 1; i >= 0; i--) {\n        if (charCodes[i] < ZCharCode) {\n            charCodes[i] += 1;\n            isAdd = true;\n            break;\n        } else if (charCodes[i] === ZCharCode) {\n            charCodes[i] = ACharCode;\n        }\n    }\n    if (!isAdd) {\n        charCodes.push(ACharCode);\n    }\n\n    return charCodesToString(charCodes);\n}\n\n/**\n * 列的字符编码数组转字符串\n * @param charCodes\n */\nexport function charCodesToString(charCodes: number[]): string {\n    return String.fromCharCode(...charCodes);\n}\n/**\n * 字符串转编码数组\n * @param colKey\n */\nexport function stringToCharCodes(colKey: string) {\n    const charCodes = [];\n    for (let i = 0; i < colKey.length; i++) {\n        charCodes.push(colKey.charCodeAt(i));\n    }\n    return charCodes;\n}\nlet colKeySumMap = {};\n/**\n * 获取列标签的大小 用于比较是否最大列 比如 最大列key: BD,当前列key: AF AF < BD\n * @param colKey\n * @returns\n */\nexport function getCharCodeSum(colKey: string): number {\n    let sum: number = colKeySumMap[colKey];\n    if (!sum) {\n        sum = 0;\n        for (let i = 0; i < colKey.length; i++) {\n            sum += colKey.charCodeAt(i) * (colKey.length - i - 1) * 100;\n        }\n        colKeySumMap[colKey] = sum;\n    }\n    return sum;\n}\n/**\n * 遍历横向表格\n * @param sheet xlsx表格对象\n * @param startRow 开始行 从1开始\n * @param startCol 列字符 比如A B\n * @param callback 遍历回调 (sheet: xlsx.Sheet, colKey: string, rowIndex: number) => void\n * @param isSheetRowEnd 是否行结束判断方法\n * @param isSheetColEnd 是否列结束判断方法\n * @param isSkipSheetRow 是否跳过行\n * @param isSkipSheetCol 是否跳过列\n */\nexport function forEachHorizontalSheet(\n    sheet: xlsx.Sheet,\n    startRow: number,\n    startCol: string,\n    callback: (sheet: xlsx.Sheet, colKey: string, rowIndex: number) => void,\n    isSheetRowEnd?: (sheet: xlsx.Sheet, rowIndex: number) => boolean,\n    isSheetColEnd?: (sheet: xlsx.Sheet, colkey: string) => boolean,\n    isSkipSheetRow?: (sheet: xlsx.Sheet, rowIndex: number) => boolean,\n    isSkipSheetCol?: (sheet: xlsx.Sheet, colKey: string) => boolean\n) {\n    const sheetRef: string = sheet[\"!ref\"];\n    const maxRowNum = parseInt(sheetRef.match(/\\d+$/)[0]);\n\n    const maxColKey = sheetRef.split(\":\")[1].match(/^[A-Za-z]+/)[0];\n    let maxColKeyCodeSum = getCharCodeSum(maxColKey);\n\n    let colCharCodes: number[];\n    let colKey: string;\n    let curColCodeSum: number = 0;\n    const startCharcodes = stringToCharCodes(startCol);\n    for (let i = startRow; i <= maxRowNum; i++) {\n        if (isSheetRowEnd ? isSheetRowEnd(sheet, i) : false) break;\n        if (isSkipSheetRow ? isSkipSheetRow(sheet, i) : false) continue;\n        colCharCodes = startCharcodes.concat([]);\n\n        colKey = startCol;\n\n        let hasNextCol = isSheetColEnd ? !isSheetColEnd(sheet, colKey) : true;\n        while (hasNextCol) {\n            if (!(isSkipSheetCol ? isSkipSheetCol(sheet, colKey) : false)) {\n                callback(sheet, colKey, i);\n            }\n            colKey = getNextColKey(colCharCodes);\n            curColCodeSum = getCharCodeSum(colKey);\n            if (maxColKeyCodeSum >= curColCodeSum) {\n                hasNextCol = isSheetColEnd ? !isSheetColEnd(sheet, colKey) : true;\n            } else {\n                hasNextCol = false;\n            }\n        }\n    }\n}\n\n/**\n * 遍历纵向表格\n * @param sheet xlsx表格对象\n * @param startRow 开始行 从1开始\n * @param startCol 列字符 比如A B\n * @param callback 遍历回调 (sheet: xlsx.Sheet, colKey: string, rowIndex: number) => void\n * @param isSheetRowEnd 是否行结束判断方法\n * @param isSheetColEnd 是否列结束判断方法\n * @param isSkipSheetRow 是否跳过行\n * @param isSkipSheetCol 是否跳过列\n */\nexport function forEachVerticalSheet(\n    sheet: xlsx.Sheet,\n    startRow: number,\n    startCol: string,\n    callback: (sheet: xlsx.Sheet, colKey: string, rowIndex: number) => void,\n    isSheetRowEnd?: (sheet: xlsx.Sheet, rowIndex: number) => boolean,\n    isSheetColEnd?: (sheet: xlsx.Sheet, colkey: string) => boolean,\n    isSkipSheetRow?: (sheet: xlsx.Sheet, rowIndex: number) => boolean,\n    isSkipSheetCol?: (sheet: xlsx.Sheet, colKey: string) => boolean\n) {\n    const sheetRef: string = sheet[\"!ref\"];\n    const maxRowNum = parseInt(sheetRef.match(/\\d+$/)[0]);\n\n    const maxColKey = sheetRef.split(\":\")[1].match(/^[A-Za-z]+/)[0];\n    const maxColKeyCodeSum = getCharCodeSum(maxColKey);\n    let colCharCodes: number[];\n    let colKey: string;\n    colCharCodes = stringToCharCodes(startCol);\n    let curColCodeSum: number = 0;\n    colKey = startCol;\n    let hasNextCol = isSheetColEnd ? !isSheetColEnd(sheet, colKey) : true;\n    while (hasNextCol) {\n        if (!(isSkipSheetCol ? isSkipSheetCol(sheet, colKey) : false)) {\n            for (let i = startRow; i <= maxRowNum; i++) {\n                if (isSheetRowEnd ? isSheetRowEnd(sheet, i) : false) break;\n                if (isSkipSheetRow ? isSkipSheetRow(sheet, i) : false) continue;\n                callback(sheet, colKey, i);\n            }\n        }\n\n        colKey = getNextColKey(colCharCodes);\n        curColCodeSum = getCharCodeSum(colKey);\n        if (maxColKeyCodeSum >= curColCodeSum) {\n            hasNextCol = isSheetColEnd ? !isSheetColEnd(sheet, colKey) : true;\n        } else {\n            hasNextCol = false;\n        }\n    }\n}\n\n/**\n * 读取配置表文件 同步的\n * @param fileInfo\n */\nexport function readTableFile(fileInfo: IFileInfo): xlsx.WorkBook {\n    const workBook = xlsx.readFile(fileInfo.filePath, { type: getTableFileType(fileInfo) });\n    return workBook;\n}\n/**\n * 读取配置表文件 同步的\n * 如果fileData typeof === string xlsx.read 的 type是string,否则是buffer\n * @param fileInfo\n */\nexport function readTableData(fileInfo: IFileInfo): xlsx.WorkBook {\n    // const workBook = xlsx.read(fileInfo.fileData, { type: isCSV(fileInfo.fileExtName) ? \"string\" : \"buffer\" });\n    const workBook = xlsx.read(fileInfo.fileData, {\n        type: typeof fileInfo.fileData === \"string\" ? \"string\" : \"buffer\"\n    });\n    return workBook;\n}\n/**\n * 获取配置文件类型\n * @param fileInfo\n * @returns\n */\nexport function getTableFileType(fileInfo: IFileInfo) {\n    return isCSV(fileInfo.fileExtName) ? \"string\" : \"file\";\n}\n/**\n * 根据文件名后缀判断是否为csv文件\n * @param fileExtName\n */\nexport function isCSV(fileExtName: string): boolean {\n    return fileExtName === \".csv\";\n}\n","import * as xlsx from \"xlsx\";\nimport { defaultValueTransFuncMap } from \"./default-value-func-map\";\nimport { Logger } from \"./loger\";\nimport {\n    forEachHorizontalSheet,\n    forEachVerticalSheet,\n    isCSV,\n    isEmptyCell,\n    readTableData,\n    readTableFile\n} from \"./table-utils\";\n\ndeclare global {\n    interface ITableParserConfig {\n        /**自定义值转换方法字典 */\n        customValueTransFuncMap?: ValueTransFuncMap;\n    }\n    interface ITableConvertConfig {\n        /**解析配置 */\n        parserConfig?: ITableParserConfig;\n    }\n    interface ITableField {\n        /**配置表中注释值 */\n        text: string;\n        /**配置表中类型值 */\n        originType: string;\n        /**配置表中字段名值 */\n        originFieldName: string;\n        /**解析后的类型值 */\n        type?: string;\n        /**解析后的字段名值 */\n        fieldName?: string;\n        /**对象的子字段名 */\n        subFieldName?: string;\n        /**多列对象 */\n        isMutiColObj?: boolean;\n    }\n    interface ITableFirstCellValue {\n        tableNameInSheet: string;\n        tableType: TableType;\n    }\n    interface ITableDefine {\n        /**配置表名 */\n        tableName: string;\n        /**配置表类型 默认两种: vertical 和 horizontal*/\n        tableType: string;\n\n        /**遍历开始行 */\n        startRow: number;\n        /**遍历开始列 */\n        startCol: string;\n        /**垂直表字段定义 */\n        verticalFieldDefine: IVerticalFieldDefine;\n        /**横向表字段定义 */\n        horizontalFieldDefine: IHorizontalFieldDefine;\n    }\n    interface IVerticalFieldDefine {\n        /**类型行 */\n        typeCol: string;\n        /**字段名行 */\n        fieldCol: string;\n        /**注释行 */\n        textCol: string;\n    }\n    interface IHorizontalFieldDefine {\n        /**类型行 */\n        typeRow: number;\n        /**字段名行 */\n        fieldRow: number;\n        /**注释行 */\n        textRow: number;\n    }\n    /**\n     * 字段字典\n     * key是列originFieldName\n     * value是字段对象\n     */\n    type TableFieldMap = { [key: string]: ITableField };\n\n    /**\n     * 表格的一行或者一列\n     * key为字段名值，value为表格的一格\n     */\n    type TableRowOrCol = { [key: string]: ITableCell };\n    /**\n     * 表格的一格\n     */\n    interface ITableCell {\n        /**字段对象 */\n        field: ITableField;\n        /**值 */\n        value: any;\n    }\n    /**\n     * 表格行或列的字典\n     * key为行索引，value为表格的一行\n     */\n    type TableRowOrColMap = { [key: string]: TableRowOrCol };\n    /**\n     * 表格行或列值数组\n     * key主键，value是值数组\n     */\n    type RowOrColValuesMap = { [key: string]: any[] };\n    interface ITableValues {\n        /**字段名数组 */\n        fields: string[];\n        /**表格值数组 */\n        rowOrColValuesMap: RowOrColValuesMap;\n    }\n    /**\n     * 解析结果\n     */\n    interface ITableParseResult {\n        /**配置表定义 */\n        tableDefine?: ITableDefine;\n        /**当前分表名 */\n        curSheetName?: string;\n        /**字段字典 */\n        fieldMap?: TableFieldMap;\n        // /**表格行或列的字典 */\n        // rowOrColMap: TableRowOrColMap\n        /**单个表格对象 */\n        /**key是主键值，value是一行对象 */\n        tableObj?: { [key: string]: any };\n        /**当前行或列对象 */\n        curRowOrColObj?: any;\n        /**主键值 */\n        mainKeyFieldName?: string;\n    }\n\n    /**值转换结果 */\n    interface ITransValueResult {\n        error?: any;\n        value?: any;\n    }\n    /**值转换方法 */\n    type ValueTransFunc = (fieldItem: ITableField, cellValue: any) => ITransValueResult;\n    /**\n     * 值转换方法字典\n     * key是类型key\n     * value是方法\n     */\n    type ValueTransFuncMap = { [key: string]: ValueTransFunc };\n}\n/**\n * 配置表类型\n * 按照字段扩展方向定\n */\nexport enum TableType {\n    /**字段垂直扩展 */\n    vertical = \"vertical\",\n    /**字段横向扩展 */\n    horizontal = \"horizontal\"\n}\n\nexport class DefaultTableParser implements ITableParser {\n    getTableDefine(fileInfo: IFileInfo, workBook: xlsx.WorkBook): ITableDefine {\n        let cellKey: string;\n        let cellObj: xlsx.CellObject;\n\n        const sheetNames = workBook.SheetNames;\n        let sheet: xlsx.Sheet;\n        let firstCanParseSheet: xlsx.Sheet;\n        //第一个格子的值tableNameInSheet(表名),tableType:表格类型\n        let firstCellValue: ITableFirstCellValue;\n        let firstCellObj: xlsx.CellObject;\n\n        const tableDefine: Partial<ITableDefine> = {};\n\n        for (let i = 0; i < sheetNames.length; i++) {\n            sheet = workBook.Sheets[sheetNames[i]];\n            firstCellObj = sheet[\"A\" + 1];\n            if (!isEmptyCell(firstCellObj)) {\n                firstCanParseSheet = sheet;\n                firstCellValue = this._getFirstCellValue(firstCellObj);\n                if (!tableDefine.tableName) {\n                    tableDefine.tableName = firstCellValue.tableNameInSheet;\n                    tableDefine.tableType = firstCellValue.tableType;\n                }\n                if (firstCellValue && firstCellValue.tableNameInSheet === tableDefine.tableName) {\n                    break;\n                }\n            }\n        }\n        if (!tableDefine.tableName || !tableDefine.tableType) {\n            return null;\n        }\n        if (tableDefine.tableType === TableType.vertical) {\n            tableDefine.verticalFieldDefine = {} as any;\n            const verticalFieldDefine = tableDefine.verticalFieldDefine;\n            verticalFieldDefine.textCol = \"A\";\n            verticalFieldDefine.typeCol = \"B\";\n            verticalFieldDefine.fieldCol = \"C\";\n            tableDefine.startCol = \"D\";\n            tableDefine.startRow = 2;\n        } else if (tableDefine.tableType === TableType.horizontal) {\n            tableDefine.horizontalFieldDefine = {} as any;\n            const horizontalFieldDefine: IHorizontalFieldDefine = tableDefine.horizontalFieldDefine;\n            horizontalFieldDefine.textRow = 1;\n            for (let i = 1; i < 100; i++) {\n                cellKey = \"A\" + i;\n                cellObj = firstCanParseSheet[cellKey];\n                if (isEmptyCell(cellObj) || cellObj.v === \"NO\" || cellObj.v === \"END\" || cellObj.v === \"START\") {\n                    tableDefine.startRow = i;\n                } else if (cellObj.v === \"CLIENT\") {\n                    horizontalFieldDefine.fieldRow = i;\n                } else if (cellObj.v === \"TYPE\") {\n                    horizontalFieldDefine.typeRow = i;\n                }\n                if (tableDefine.startRow && horizontalFieldDefine.fieldRow && horizontalFieldDefine.typeRow) break;\n            }\n\n            tableDefine.startCol = \"B\";\n        }\n\n        return tableDefine as any;\n    }\n    private _getFirstCellValue(firstCellObj: xlsx.CellObject): ITableFirstCellValue {\n        if (!firstCellObj) return;\n        const cellValues = (firstCellObj.v as string).split(\":\");\n        let tableNameInSheet: string;\n        let tableType: TableType;\n        if (cellValues.length > 1) {\n            tableNameInSheet = cellValues[1];\n            tableType = cellValues[0] === \"V\" ? TableType.vertical : TableType.horizontal;\n        } else {\n            tableNameInSheet = cellValues[0];\n            tableType = TableType.horizontal;\n        }\n        return { tableNameInSheet: tableNameInSheet, tableType: tableType };\n    }\n    /**\n     * 判断表格是否能解析\n     * @param sheet\n     */\n    checkSheetCanParse(tableDefine: ITableDefine, sheet: xlsx.Sheet, sheetName: string): boolean {\n        //如果这个表个第一格值不等于表名，则不解析\n        const firstCellObj: xlsx.CellObject = sheet[\"A\" + 1];\n        const firstCellValue = this._getFirstCellValue(firstCellObj);\n        if (firstCellObj && tableDefine) {\n            if (firstCellValue.tableNameInSheet !== tableDefine.tableName) {\n                return false;\n            }\n            return true;\n        } else {\n            return false;\n        }\n    }\n    /**\n     * 表行结束判断\n     * @param tableDefine\n     * @param sheet\n     * @param row\n     */\n    isSheetRowEnd(tableDefine: ITableDefine, sheet: xlsx.Sheet, row: number): boolean {\n        // if (tableDefine.tableType === TableType.vertical) {\n\n        // } else if (tableDefine.tableType === TableType.horizontal) {\n\n        // }\n        //判断上一行的标志是否为END\n        if (row > 1) {\n            row = row - 1;\n            const cellObj: xlsx.CellObject = sheet[\"A\" + row];\n            return cellObj && cellObj.v === \"END\";\n        } else {\n            return false;\n        }\n    }\n    /**\n     * 表列结束判断\n     * @param tableDefine\n     * @param sheet\n     * @param colKey\n     */\n    isSheetColEnd(tableDefine: ITableDefine, sheet: xlsx.Sheet, colKey: string): boolean {\n        //判断这一列第一行是否为空\n        const firstCellObj: xlsx.CellObject = sheet[colKey + 1];\n        // const typeCellObj: xlsx.CellObject = sheet[colKey + tableFile.tableDefine.typeRow];\n        return isEmptyCell(firstCellObj);\n    }\n    /**\n     * 检查行是否需要解析\n     * @param tableDefine\n     * @param sheet\n     * @param rowIndex\n     */\n    checkRowNeedParse(tableDefine: ITableDefine, sheet: xlsx.Sheet, rowIndex: number): boolean {\n        const cellObj: xlsx.CellObject = sheet[\"A\" + rowIndex];\n        if (cellObj && cellObj.v === \"NO\") {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * 解析横向表格的单个格子\n     * @param tableParseResult\n     * @param sheet\n     * @param colKey\n     * @param rowIndex\n     * @param isNewRowOrCol 是否为新的一行或者一列\n     */\n    parseHorizontalCell(\n        valueTransFuncMap: ValueTransFuncMap,\n        tableParseResult: ITableParseResult,\n        sheet: xlsx.Sheet,\n        colKey: string,\n        rowIndex: number,\n        isNewRowOrCol: boolean\n    ): void {\n        const fieldInfo = this.getHorizontalTableField(tableParseResult, sheet, colKey, rowIndex);\n        if (!fieldInfo) return;\n        const cell: xlsx.CellObject = sheet[colKey + rowIndex];\n        if (isEmptyCell(cell)) {\n            return;\n        }\n\n        const transResult = this.transValue(valueTransFuncMap, tableParseResult, fieldInfo, cell.v);\n        if (transResult.error) {\n            tableParseResult.hasError = true;\n            Logger.log(\n                `!!!!!!!!!!!!!!!!!![-----解析错误-----]!!!!!!!!!!!!!!!!!!!!!!!!!\\n` +\n                    `[sheetName|分表名]=> ${tableParseResult.curSheetName}\\n` +\n                    `[row|行]=> ${rowIndex}\\n` +\n                    `[col|列]=> ${colKey}\\n` +\n                    `[field|字段]=> ${fieldInfo.originFieldName}\\n` +\n                    `[type|类型]=> ${fieldInfo.originType}\\n` +\n                    `[error|错误]=> ${\n                        typeof transResult.error === \"string\" ? transResult.error : transResult.error.message\n                    }\\n`,\n                \"error\"\n            );\n            // Logger.log(transResult.error, \"error\");\n        }\n        const transedValue = transResult.value;\n        let mainKeyFieldName: string = tableParseResult.mainKeyFieldName;\n        if (!mainKeyFieldName) {\n            //第一个字段就是主键\n            mainKeyFieldName = fieldInfo.fieldName;\n            tableParseResult.mainKeyFieldName = fieldInfo.fieldName;\n            tableParseResult.tableObj = {};\n        }\n        let rowOrColObj: any = tableParseResult.curRowOrColObj;\n        if (isNewRowOrCol) {\n            //新的一行\n            rowOrColObj = {};\n            tableParseResult.curRowOrColObj = tableParseResult.tableObj[transedValue] = rowOrColObj;\n        }\n\n        if (fieldInfo.isMutiColObj) {\n            let subObj = rowOrColObj[fieldInfo.fieldName];\n            if (!subObj) {\n                subObj = {};\n                rowOrColObj[fieldInfo.fieldName] = subObj;\n            }\n            subObj[fieldInfo.subFieldName] = transedValue;\n        } else {\n            rowOrColObj[fieldInfo.fieldName] = transedValue;\n        }\n    }\n    /**\n     * 解析纵向表格的单个格子\n     * @param valueTransFuncMap\n     * @param tableParseResult\n     * @param sheet\n     * @param colKey\n     * @param rowIndex\n     * @param isNewRowOrCol 是否为新的一行或者一列\n     */\n    parseVerticalCell(\n        valueTransFuncMap: ValueTransFuncMap,\n        tableParseResult: ITableParseResult,\n        sheet: xlsx.Sheet,\n        colKey: string,\n        rowIndex: number,\n        isNewRowOrCol: boolean\n    ): void {\n        const fieldInfo = this.getVerticalTableField(tableParseResult, sheet, colKey, rowIndex);\n        if (!fieldInfo) return;\n        const cell: xlsx.CellObject = sheet[colKey + rowIndex];\n        if (isEmptyCell(cell)) {\n            return;\n        }\n        const transResult = this.transValue(valueTransFuncMap, tableParseResult, fieldInfo, cell.v);\n        if (transResult.error) {\n            Logger.log(\n                `!!!!!!!!!!!!!!!!!![-----ParseError|解析错误-----]!!!!!!!!!!!!!!!!!!!!!!!!!\\n` +\n                    `[sheetName|分表名]=> ${tableParseResult.curSheetName}\\n` +\n                    `[row|行]=> ${rowIndex}\\n` +\n                    `[col|列]=> ${colKey}\\n` +\n                    `[field|字段]=> ${fieldInfo.originFieldName}\\n` +\n                    `[type|类型]=> ${fieldInfo.originType}\\n` +\n                    `[error|错误]=> ${\n                        typeof transResult.error === \"string\" ? transResult.error : transResult.error.message\n                    }\\n` +\n                    `!!!!!!!!!!!!!!!!!![-----ParseError|解析错误-----]!!!!!!!!!!!!!!!!!!!!!!!!!\\n`,\n\n                \"error\"\n            );\n        }\n        const transedValue = transResult.value;\n        if (!tableParseResult.tableObj) {\n            tableParseResult.tableObj = {};\n        }\n        if (fieldInfo.isMutiColObj) {\n            let subObj = tableParseResult.tableObj[fieldInfo.fieldName];\n            if (!subObj) {\n                subObj = {};\n                tableParseResult.tableObj[fieldInfo.fieldName] = subObj;\n            }\n            subObj[fieldInfo.subFieldName] = transedValue;\n        } else {\n            tableParseResult.tableObj[fieldInfo.fieldName] = transedValue;\n        }\n    }\n    /**\n     * 解析出横向表的字段对象\n     * @param tableParseResult\n     * @param sheet\n     * @param colKey\n     * @param rowIndex\n     */\n    getHorizontalTableField(\n        tableParseResult: ITableParseResult,\n        sheet: xlsx.Sheet,\n        colKey: string,\n        rowIndex: number\n    ): ITableField {\n        const tableDefine = tableParseResult.tableDefine;\n        let tableFieldMap = tableParseResult.fieldMap;\n        if (!tableFieldMap) {\n            tableFieldMap = {};\n            tableParseResult.fieldMap = tableFieldMap;\n        }\n        const horizontalFieldDefine = tableDefine.horizontalFieldDefine;\n        const fieldCell = sheet[colKey + horizontalFieldDefine.fieldRow];\n        let originFieldName: string;\n        if (!isEmptyCell(fieldCell)) {\n            originFieldName = fieldCell.v as string;\n        }\n        if (!originFieldName) return null;\n        let field: ITableField = {} as any;\n        //缓存\n        if (tableFieldMap[originFieldName] !== undefined) {\n            return tableFieldMap[originFieldName];\n        }\n        //注释\n        const textCell: xlsx.CellObject = sheet[colKey + horizontalFieldDefine.textRow];\n        if (!isEmptyCell(textCell)) {\n            field.text = textCell.v as string;\n        }\n        //类型\n        let isObjType: boolean = false;\n        const typeCell = sheet[colKey + horizontalFieldDefine.typeRow];\n\n        if (isEmptyCell(typeCell)) {\n            return null;\n        } else {\n            field.originType = typeCell.v as string;\n            if (field.originType.includes(\"mf:\")) {\n                const typeStrs = field.originType.split(\":\");\n                if (typeStrs.length < 3) {\n                    return null;\n                }\n                field.type = typeStrs[2];\n                isObjType = true;\n            } else {\n                field.type = field.originType;\n            }\n        }\n        field.isMutiColObj = isObjType;\n        //字段名\n        field.originFieldName = originFieldName;\n        if (isObjType) {\n            const fieldStrs = field.originFieldName.split(\":\");\n            if (fieldStrs.length < 2) {\n                return null;\n            }\n            field.fieldName = fieldStrs[0];\n            field.subFieldName = fieldStrs[1];\n        } else {\n            field.fieldName = field.originFieldName;\n        }\n\n        tableFieldMap[originFieldName] = field;\n        return field;\n    }\n    /**\n     * 解析出纵向表的字段类型对象\n     * @param tableParseResult\n     * @param sheet\n     * @param colKey\n     * @param rowIndex\n     * @returns\n     */\n    getVerticalTableField(\n        tableParseResult: ITableParseResult,\n        sheet: xlsx.Sheet,\n        colKey: string,\n        rowIndex: number\n    ): ITableField {\n        const tableDefine = tableParseResult.tableDefine;\n        let tableFieldMap = tableParseResult.fieldMap;\n        if (!tableFieldMap) {\n            tableFieldMap = {};\n            tableParseResult.fieldMap = tableFieldMap;\n        }\n        const verticalFieldDefine = tableDefine.verticalFieldDefine;\n        const fieldNameCell: xlsx.CellObject = sheet[verticalFieldDefine.fieldCol + rowIndex];\n        let originFieldName: string;\n        if (!isEmptyCell(fieldNameCell)) {\n            originFieldName = fieldNameCell.v as string;\n        }\n        if (!originFieldName) return null;\n        if (tableFieldMap[originFieldName] !== undefined) {\n            return tableFieldMap[originFieldName];\n        }\n        let field: ITableField = {} as any;\n\n        const textCell: xlsx.CellObject = sheet[verticalFieldDefine.textCol + rowIndex];\n        //注释\n        if (!isEmptyCell(textCell)) {\n            field.text = textCell.v as string;\n        }\n        let isObjType: boolean = false;\n        //类型\n        const typeCell: xlsx.CellObject = sheet[verticalFieldDefine.typeCol + rowIndex];\n\n        if (isEmptyCell(typeCell)) {\n            return null;\n        } else {\n            //处理类型\n            field.originType = typeCell.v as string;\n            if (field.originType.includes(\"mf:\")) {\n                const typeStrs = field.originType.split(\":\");\n                if (typeStrs.length < 3) {\n                    return null;\n                }\n                field.type = typeStrs[2];\n                isObjType = true;\n            } else {\n                field.type = field.originType;\n            }\n        }\n        field.isMutiColObj = isObjType;\n        field.originFieldName = originFieldName;\n        if (isObjType) {\n            const fieldStrs = field.originFieldName.split(\":\");\n            if (fieldStrs.length < 2) {\n                return null;\n            }\n            field.fieldName = fieldStrs[0];\n            field.subFieldName = fieldStrs[1];\n        } else {\n            field.fieldName = field.originFieldName;\n        }\n        tableFieldMap[originFieldName] = field;\n        return field;\n    }\n    /**\n     * 检查列是否需要解析\n     * @param tableDefine\n     * @param sheet\n     * @param colKey\n     */\n    checkColNeedParse(tableDefine: ITableDefine, sheet: xlsx.Sheet, colKey: string): boolean {\n        // 如果类型或者则不需要解析\n        if (tableDefine.tableType === TableType.vertical) {\n            const cellObj: xlsx.CellObject = sheet[colKey + 1];\n            if (isEmptyCell(cellObj)) {\n                return false;\n            } else {\n                return true;\n            }\n        } else if (tableDefine.tableType === TableType.horizontal) {\n            const horizontalFieldDefine = tableDefine.horizontalFieldDefine;\n            const typeCellObj: xlsx.CellObject = sheet[colKey + horizontalFieldDefine.typeRow];\n            const fieldCellObj: xlsx.CellObject = sheet[colKey + horizontalFieldDefine.fieldRow];\n            if (isEmptyCell(typeCellObj) || isEmptyCell(fieldCellObj)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n    }\n    /**\n     * 转换表格的值\n     * @param parseResult\n     * @param fieldItem\n     * @param cellValue\n     */\n    public transValue(\n        valueTransFuncMap: ValueTransFuncMap,\n        parseResult: ITableParseResult,\n        fieldItem: ITableField,\n        cellValue: any\n    ): ITransValueResult {\n        let transResult: ITransValueResult;\n\n        let transFunc = valueTransFuncMap[fieldItem.type];\n        if (!transFunc) {\n            transFunc = valueTransFuncMap[\"json\"];\n        }\n        transResult = transFunc(fieldItem, cellValue);\n        return transResult;\n    }\n\n    /**\n     * 解析配置表文件\n     * @param convertConfig 解析配置\n     * @param fileInfo 文件信息\n     * @param parseResult 解析结果\n     */\n    public parseTableFile(\n        convertConfig: ITableConvertConfig,\n        fileInfo: IFileInfo,\n        parseResult: ITableParseResult\n    ): ITableParseResult {\n        fileInfo.fileData = isCSV(fileInfo.fileExtName) ? (fileInfo.fileData as Buffer).toString() : fileInfo.fileData;\n        const workbook = readTableData(fileInfo);\n        if (!workbook.SheetNames.length) return;\n        let valueTransFuncMap = convertConfig?.parserConfig?.customValueTransFuncMap;\n\n        if (!valueTransFuncMap) {\n            valueTransFuncMap = defaultValueTransFuncMap;\n        } else {\n            valueTransFuncMap = Object.assign(valueTransFuncMap, defaultValueTransFuncMap);\n        }\n\n        const sheetNames = workbook.SheetNames;\n        const tableDefine: ITableDefine = this.getTableDefine(fileInfo, workbook);\n\n        if (!tableDefine) {\n            Logger.log(`表格不规范,跳过解析,路径:${fileInfo.filePath}`, \"warn\");\n            return;\n        }\n        let sheetName: string;\n        let sheet: xlsx.Sheet;\n        const isSheetRowEnd = this.isSheetRowEnd.bind(null, tableDefine);\n        const isSheetColEnd = this.isSheetColEnd.bind(null, tableDefine);\n        const isSkipSheetRow = (sheet: xlsx.Sheet, rowIndex: number) => {\n            return !this.checkRowNeedParse(tableDefine, sheet, rowIndex);\n        };\n        const isSkipSheetCol = (sheet: xlsx.Sheet, colKey: string) => {\n            return !this.checkColNeedParse(tableDefine, sheet, colKey);\n        };\n        let cellObj: xlsx.CellObject;\n        parseResult.tableDefine = tableDefine;\n        Logger.log(`[parseTable|解析文件]=> ${fileInfo.filePath}`);\n        for (let i = 0; i < sheetNames.length; i++) {\n            sheetName = sheetNames[i];\n            sheet = workbook.Sheets[sheetName];\n            if (!this.checkSheetCanParse(tableDefine, sheet, sheetName)) {\n                continue;\n            }\n            parseResult.curSheetName = sheetName;\n            Logger.log(`|=[parseSheet|解析分表]=> ${sheetName}`);\n            if (tableDefine.tableType === TableType.horizontal) {\n                let lastRowIndex: number;\n\n                forEachHorizontalSheet(\n                    sheet,\n                    tableDefine.startRow,\n                    tableDefine.startCol,\n                    (sheet, colKey: string, rowIndex: number) => {\n                        let isNewRowOrCol = false;\n                        if (lastRowIndex !== rowIndex) {\n                            lastRowIndex = rowIndex;\n                            isNewRowOrCol = true;\n                        }\n                        cellObj = sheet[colKey + rowIndex];\n                        this.parseHorizontalCell(\n                            valueTransFuncMap,\n                            parseResult,\n                            sheet,\n                            colKey,\n                            rowIndex,\n                            isNewRowOrCol\n                        );\n                    },\n                    isSheetRowEnd,\n                    isSheetColEnd,\n                    isSkipSheetRow,\n                    isSkipSheetCol\n                );\n            } else if (tableDefine.tableType === TableType.vertical) {\n                let lastColKey: string;\n\n                forEachVerticalSheet(\n                    sheet,\n                    tableDefine.startRow,\n                    tableDefine.startCol,\n                    (sheet, colKey: string, rowIndex: number) => {\n                        let isNewRowOrCol = false;\n                        if (lastColKey !== colKey) {\n                            lastColKey = colKey;\n                            isNewRowOrCol = true;\n                        }\n\n                        cellObj = sheet[colKey + rowIndex];\n                        if (!isEmptyCell(cellObj)) {\n                            this.parseVerticalCell(\n                                valueTransFuncMap,\n                                parseResult,\n                                sheet,\n                                colKey,\n                                rowIndex,\n                                isNewRowOrCol\n                            );\n                        }\n                    },\n                    isSheetRowEnd,\n                    isSheetColEnd,\n                    isSkipSheetRow,\n                    isSkipSheetCol\n                );\n            }\n        }\n\n        return parseResult as any;\n    }\n}\n","import * as path from \"path\";\nimport { TableType } from \"./default-table-parser\";\nimport { deflateSync } from \"zlib\";\nimport { osEol } from \"./get-os-eol\";\nimport { Logger } from \"./loger\";\ndeclare global {\n    interface ITableConvertConfig {\n        /**输出配置 */\n        outputConfig?: IOutputConfig;\n    }\n    /**\n     * 输出配置\n     */\n    interface IOutputConfig {\n        /**自定义 配置字段类型和ts声明类型字符串映射字典 */\n        customTypeStrMap?: { [key: string]: string };\n        /**单个配置表json输出目录路径 */\n        clientSingleTableJsonDir?: string;\n        /**合并配置表json文件路径(包含文件名,比如 ./out/bundle.json) */\n        clientBundleJsonOutPath?: string;\n        /**是否格式化合并后的json，默认不 */\n        isFormatBundleJson?: boolean;\n        /**声明文件输出目录(每个配置表一个声明)，默认不输出 */\n        clientDtsOutDir?: string;\n        /**是否合并所有声明为一个文件,默认true */\n        isBundleDts?: boolean;\n        /**合并后的声明文件名,如果没有则默认为tableMap */\n        bundleDtsFileName?: string;\n        /**是否将json格式压缩,默认否,减少json字段名字符,效果较小 */\n        isCompress?: boolean;\n        /**是否Zip压缩,使用zlib */\n        isZip?: boolean;\n    }\n}\n\n/**类型字符串映射字典 */\nconst defaultTypeStrMap = { int: \"number\", json: \"any\", \"[int]\": \"number[]\", \"[string]\": \"string[]\" };\nexport class DefaultParseResultTransformer {\n    /**\n     * 转换\n     * @param context\n     * @returns\n     */\n    transform(context: IConvertContext, cb: VoidFunction) {\n        const convertConfig = context.convertConfig;\n        const parseResultMap = context.parseResultMap;\n        let outputConfig: IOutputConfig = convertConfig.outputConfig;\n        if (!outputConfig) {\n            console.error(`导出配置outputConfig is undefind`);\n            return;\n        }\n        let typeStrMap = defaultTypeStrMap;\n        if (outputConfig.customTypeStrMap) {\n            typeStrMap = Object.assign(defaultTypeStrMap, outputConfig.customTypeStrMap);\n        }\n        let tableObjMap: { [key: string]: any } = {};\n        let tableFieldInfoMap: { [key: string]: { [key: string]: ITableField } } = {};\n        let fieldInfoMap: { [key: string]: ITableField };\n        let outputFileMap: OutPutFileMap = {};\n        let tableTypeMapDtsStr = \"\";\n        let tableTypeDtsStrs = \"\";\n        let parseResult: ITableParseResult;\n        let tableName: string;\n        let tableObj: any;\n        let isObjTypeTableMap: { [key: string]: boolean } = {};\n        Logger.log(`[outputTransform |转换解析结果]请稍等...`);\n        for (let filePath in parseResultMap) {\n            parseResult = parseResultMap[filePath];\n            //没有定义，没有值，就跳过输出处理\n            if (!parseResult.tableDefine || !parseResult.tableObj) continue;\n\n            tableName = parseResult.tableDefine.tableName;\n\n            //合并多个同名表\n            tableObj = tableObjMap[tableName];\n            //合并表值\n            if (tableObj) {\n                tableObj = Object.assign(tableObj, parseResult.tableObj);\n            } else {\n                tableObj = parseResult.tableObj;\n            }\n            tableObjMap[tableName] = tableObj;\n            //合并表类型数据\n            fieldInfoMap = tableFieldInfoMap[tableName];\n            if (fieldInfoMap) {\n                fieldInfoMap = Object.assign(fieldInfoMap, parseResult.fieldMap);\n            } else {\n                fieldInfoMap = parseResult.fieldMap;\n            }\n            tableFieldInfoMap[tableName] = fieldInfoMap;\n\n            if (outputConfig.clientDtsOutDir && isObjTypeTableMap[tableName] === undefined) {\n                isObjTypeTableMap[tableName] = parseResult.tableDefine.tableType === TableType.vertical;\n                if (parseResult.tableDefine.tableType === TableType.vertical) {\n                    tableTypeMapDtsStr += \"\\treadonly \" + tableName + \"?: \" + `IT_${tableName};` + osEol;\n                } else {\n                    tableTypeMapDtsStr += this._getOneTableTypeStr(tableName);\n                }\n            }\n        }\n        for (let tableName in tableObjMap) {\n            //生成单个表json\n            if (outputConfig.clientSingleTableJsonDir) {\n                this._addSingleTableJsonOutputFile(outputConfig, tableName, tableObjMap[tableName], outputFileMap);\n            }\n            if (outputConfig.isBundleDts === undefined) outputConfig.isBundleDts = true;\n            if (!outputConfig.isBundleDts) {\n                //输出单个声明文件\n                this._addSingleTableDtsOutputFile(outputConfig, tableName, tableFieldInfoMap[tableName], outputFileMap);\n            } else {\n                //合并声明文件\n                tableTypeDtsStrs += this._getSingleTableDts(typeStrMap, tableName, tableFieldInfoMap[tableName]);\n            }\n        }\n        if (outputConfig.clientDtsOutDir) {\n            //输出声明文件\n\n            let itBaseStr = \"interface ITBase<T> { [key:string]:T}\" + osEol;\n\n            tableTypeMapDtsStr = itBaseStr + \"interface IT_TableMap {\" + osEol + tableTypeMapDtsStr + \"}\" + osEol;\n\n            if (outputConfig.isBundleDts) {\n                //合成一个文件\n                const dtsFileName = outputConfig.bundleDtsFileName ? outputConfig.bundleDtsFileName : \"tableMap\";\n                const bundleDtsFilePath = path.join(outputConfig.clientDtsOutDir, `${dtsFileName}.d.ts`);\n                outputFileMap[bundleDtsFilePath] = {\n                    filePath: bundleDtsFilePath,\n                    data: tableTypeMapDtsStr + tableTypeDtsStrs\n                };\n            } else {\n                //拆分文件输出，但也会有一个map文件\n                const tableTypeMapDtsFilePath = path.join(outputConfig.clientDtsOutDir, \"tableMap.d.ts\");\n                outputFileMap[tableTypeMapDtsFilePath] = {\n                    filePath: tableTypeMapDtsFilePath,\n                    data: tableTypeMapDtsStr\n                };\n            }\n        }\n\n        //输出合并后的json\n        if (outputConfig.clientBundleJsonOutPath) {\n            let jsonBundleFilePath = outputConfig.clientBundleJsonOutPath;\n            let outputData: any;\n            if (outputConfig.isCompress) {\n                //进行格式压缩\n                const newTableObjMap = {};\n                let tableObj: any;\n                let newTableObj: any;\n                for (let tableName in tableObjMap) {\n                    if (isObjTypeTableMap[tableName]) {\n                        newTableObjMap[tableName] = tableObjMap[tableName];\n                        continue;\n                    }\n                    tableObj = tableObjMap[tableName];\n                    newTableObj = { fieldValuesMap: {} };\n                    for (let mainKey in tableObj) {\n                        if (!newTableObj.fieldNames) {\n                            newTableObj.fieldNames = Object.keys(tableObj[mainKey]);\n                        }\n                        newTableObj.fieldValuesMap[mainKey] = Object.values(tableObj[mainKey]);\n                    }\n                    newTableObjMap[tableName] = newTableObj;\n                }\n                outputData = JSON.stringify(newTableObjMap);\n            } else {\n                outputData = JSON.stringify(tableObjMap);\n            }\n            //进行base64处理\n            // if (outputConfig.bundleJsonIsEncode2Base64) {\n            //     outputData = Base64.encode(outputData);\n            //     if (outputConfig.preBase64UglyString) {\n            //         outputData = outputConfig.preBase64UglyString + outputData;\n            //     }\n            //     if (outputConfig.sufBase64UglyString) {\n            //         outputData += outputConfig.sufBase64UglyString;\n            //     }\n            // }\n            if (outputConfig.isZip) {\n                //使用zilb压缩\n                outputData = deflateSync(outputData);\n            }\n            outputFileMap[jsonBundleFilePath] = {\n                filePath: jsonBundleFilePath,\n                encoding: typeof outputData !== \"string\" ? \"binary\" : \"utf-8\",\n                data: outputData\n            };\n        }\n        if (context.outPutFileMap) {\n            for (let key in outputFileMap) {\n                context.outPutFileMap[key] = outputFileMap[key];\n            }\n        } else {\n            context.outPutFileMap = outputFileMap;\n        }\n        cb();\n    }\n    private _addSingleTableDtsOutputFile(\n        config: IOutputConfig,\n        tableName: string,\n        colKeyTableFieldMap: { [key: string]: ITableField },\n        outputFileMap: OutPutFileMap\n    ): void {\n        let dtsFilePath: string = path.join(config.clientDtsOutDir, `${tableName}.d.ts`);\n        let typeStrMap = defaultTypeStrMap;\n        if (config.customTypeStrMap) {\n            typeStrMap = Object.assign(defaultTypeStrMap, config.customTypeStrMap);\n        }\n        if (!outputFileMap[dtsFilePath]) {\n            //\n            const dtsStr = this._getSingleTableDts(typeStrMap, tableName, colKeyTableFieldMap);\n            if (dtsStr) {\n                outputFileMap[dtsFilePath] = { filePath: dtsFilePath, data: dtsStr } as any;\n            }\n        }\n    }\n    /**\n     * 解析出单个配置表类型数据\n     * @param parseResult\n     */\n    private _getSingleTableDts(\n        typeStrMap: { [key: string]: string },\n        tableName: string,\n        tableFieldMap: TableFieldMap\n    ): string {\n        let itemInterface = \"interface IT_\" + tableName + \" {\" + osEol;\n        let tableField: ITableField;\n        let typeStr: string;\n        let objTypeStrMap: { [key: string]: string } = {};\n\n        for (let originFieldName in tableFieldMap) {\n            tableField = tableFieldMap[originFieldName];\n            if (!tableField) continue;\n            if (!tableField.isMutiColObj) {\n                //注释行\n                itemInterface += \"\\t/** \" + tableField.text + \" */\" + osEol;\n                //字段类型声明行\n                itemInterface +=\n                    \"\\treadonly \" +\n                    tableField.fieldName +\n                    \"?: \" +\n                    (typeStrMap[tableField.type] ? typeStrMap[tableField.type] : tableField.type) +\n                    \";\" +\n                    osEol;\n            } else {\n                const objFieldKey = tableField.fieldName;\n                if (!objTypeStrMap[objFieldKey]) {\n                    objTypeStrMap[objFieldKey] = \"\";\n                }\n\n                //注释行\n                objTypeStrMap[objFieldKey] += \"\\t\\t/** \" + tableField.text + \" */\" + osEol;\n\n                //字段类型声明行\n                objTypeStrMap[objFieldKey] +=\n                    \"\\t\\treadonly \" +\n                    tableField.subFieldName +\n                    \"?: \" +\n                    (typeStrMap[tableField.type] ? typeStrMap[tableField.type] : tableField.type) +\n                    \";\" +\n                    osEol;\n            }\n        }\n        //第二层对象\n        for (let objFieldKey in objTypeStrMap) {\n            //字段类型声明行\n            itemInterface += \"\\treadonly \" + objFieldKey + \"?: {\" + osEol + objTypeStrMap[objFieldKey];\n            itemInterface += \"\\t}\" + osEol;\n        }\n        itemInterface += \"}\" + osEol;\n\n        return itemInterface;\n    }\n    /**\n     * 添加单独导出配置表json文件\n     * @param config\n     * @param parseResult\n     * @param outputFileMap\n     */\n    private _addSingleTableJsonOutputFile(\n        config: IOutputConfig,\n        tableName: string,\n        tableObj: any,\n        outputFileMap: OutPutFileMap\n    ) {\n        if (!tableObj) return;\n        let singleJsonFilePath = path.join(config.clientSingleTableJsonDir, `${tableName}.json`);\n        let singleJsonData = JSON.stringify(tableObj, null, \"\\t\");\n\n        let singleOutputFileInfo = outputFileMap[singleJsonFilePath];\n        if (singleOutputFileInfo) {\n            singleOutputFileInfo.data = singleJsonData;\n        } else {\n            singleOutputFileInfo = {\n                filePath: singleJsonFilePath,\n                data: singleJsonData\n            };\n            outputFileMap[singleJsonFilePath] = singleOutputFileInfo;\n        }\n    }\n    private _getOneTableTypeStr(tableName: string): string {\n        return \"\\treadonly \" + tableName + \"?: \" + \"ITBase<\" + \"IT_\" + tableName + \">;\" + osEol;\n    }\n}\n","import { DefaultParseResultTransformer } from \"./default-result-transformer\";\nimport { DefaultTableParser } from \"./default-table-parser\";\nimport { Logger } from \"./loger\";\nexport class DefaultConvertHook implements IConvertHook {\n    protected _tableParser;\n    protected _tableResultTransformer;\n    constructor() {\n        this._tableParser = new DefaultTableParser();\n        this._tableResultTransformer = new DefaultParseResultTransformer();\n    }\n    onStart?(context: IConvertContext, cb: VoidFunction): void {\n        Logger.systemLog(`[excel2all] convert-hook onStart`);\n        Logger.systemLog(`[excel2all] 开始表转换`);\n        cb();\n    }\n\n    onParseBefore?(context: IConvertContext, cb: VoidFunction): void {\n        Logger.systemLog(`convert-hook onParseBefore`);\n        cb();\n    }\n    onParse(context: IConvertContext, cb: VoidFunction): void {\n        const { changedFileInfos, parseResultMap, convertConfig } = context;\n        const tableParser = this._tableParser;\n        let parseResult: ITableParseResult;\n        let fileNum = changedFileInfos.length;\n        let fileInfo: IFileInfo;\n        for (let i = 0; i < fileNum; i++) {\n            fileInfo = changedFileInfos[i];\n            parseResult = parseResultMap[fileInfo.filePath];\n            if (!parseResult) {\n                parseResult = { filePath: fileInfo.filePath };\n            }\n            parseResult = tableParser.parseTableFile(convertConfig, fileInfo, parseResult);\n            if (parseResult) {\n                parseResultMap[fileInfo.filePath] = parseResult;\n            }\n        }\n        cb();\n    }\n    onParseAfter?(context: IConvertContext, cb: VoidFunction): void {\n        let transformer = this._tableResultTransformer;\n\n        transformer.transform(context, cb);\n    }\n    onConvertEnd(context: IConvertContext): void {\n        Logger.systemLog(`convert-hook onWriteFileEnd 写入结束`);\n    }\n}\n","import * as fs from \"fs-extra\";\nimport * as path from \"path\";\nimport * as crypto from \"crypto\";\nimport { Logger } from \"./loger\";\n\ndeclare global {\n    interface IOutPutFileInfo {\n        filePath: string;\n        /**写入编码，字符串默认utf8 */\n        encoding?: BufferEncoding;\n        /**是否删除 */\n        isDelete?: boolean;\n        data?: any;\n    }\n}\n/**\n * 遍历文件\n * @param dirPath 文件夹路径\n * @param eachCallback 遍历回调 (filePath: string) => void\n */\nexport function forEachFile(fileOrDirPath: string, eachCallback?: (filePath: string) => void) {\n    if (fs.statSync(fileOrDirPath).isDirectory() && fileOrDirPath !== \".git\" && fileOrDirPath !== \".svn\") {\n        const fileNames = fs.readdirSync(fileOrDirPath);\n        let childFilePath: string;\n        for (var i = 0; i < fileNames.length; i++) {\n            childFilePath = path.join(fileOrDirPath, fileNames[i]);\n            forEachFile(childFilePath, eachCallback);\n        }\n    } else {\n        eachCallback(fileOrDirPath);\n    }\n}\n/**\n * 批量写入和删除文件\n * @param outputFileInfos 需要写入的文件信息数组\n * @param onProgress 进度变化回调\n * @param complete 完成回调\n */\nexport function writeOrDeleteOutPutFiles(\n    outputFileInfos: IOutPutFileInfo[],\n    onProgress?: (filePath: string, total: number, now: number, isOk: boolean) => void,\n    complete?: (total: number) => void\n) {\n    let fileInfo: IOutPutFileInfo;\n    const total = outputFileInfos.length;\n    if (outputFileInfos && total) {\n        let now = 0;\n        const onWriteEnd = (err) => {\n            if (err) {\n                Logger.log(err, \"error\");\n            }\n            now++;\n            onProgress && onProgress(outputFileInfos[now - 1].filePath, total, now, !err);\n            if (now >= total) {\n                complete && complete(total);\n            }\n        };\n        for (let i = outputFileInfos.length - 1; i >= 0; i--) {\n            fileInfo = outputFileInfos[i];\n\n            if (fileInfo.isDelete && fs.existsSync(fileInfo.filePath)) {\n                fs.unlinkSync(fileInfo.filePath);\n            } else {\n                if (fs.existsSync(fileInfo.filePath) && fs.statSync(fileInfo.filePath).isDirectory()) {\n                    Logger.log(`路径为文件夹:${fileInfo.filePath}`, \"error\");\n                    continue;\n                }\n\n                if (!fileInfo.encoding && typeof fileInfo.data === \"string\") {\n                    fileInfo.encoding = \"utf8\";\n                }\n                fs.ensureFileSync(fileInfo.filePath);\n                fs.writeFile(\n                    fileInfo.filePath,\n                    fileInfo.data,\n                    fileInfo.encoding ? { encoding: fileInfo.encoding } : undefined,\n                    onWriteEnd\n                );\n            }\n        }\n    }\n}\n/**\n * 获取变化过的文件数组\n * @param dir 目标目录\n * @param cacheFilePath 缓存文件绝对路径\n * @param eachCallback 遍历回调\n * @returns 返回缓存文件路径\n */\nexport function forEachChangedFile(\n    dir: string,\n    cacheFilePath?: string,\n    eachCallback?: (filePath: string, isDelete?: boolean) => void\n) {\n    const gcfCache = getCacheData(cacheFilePath);\n    const oldFilePaths = Object.keys(gcfCache);\n    let oldFilePathIndex: number;\n    forEachFile(dir, (filePath) => {\n        var md5str = getFileMd5Sync(filePath);\n        if (!gcfCache[filePath] || (gcfCache[filePath] && gcfCache[filePath] !== md5str)) {\n            gcfCache[filePath] = md5str;\n            eachCallback(filePath, false);\n        }\n        oldFilePathIndex = oldFilePaths.indexOf(filePath);\n        if (oldFilePathIndex > -1) {\n            const endFilePath = oldFilePaths[oldFilePaths.length - 1];\n            oldFilePaths[oldFilePathIndex] = endFilePath;\n            oldFilePaths.pop();\n        }\n    });\n    for (let i = 0; i < oldFilePaths.length; i++) {\n        delete gcfCache[oldFilePaths[i]];\n        eachCallback(oldFilePaths[i], true);\n    }\n    fs.writeFileSync(cacheFilePath, JSON.stringify(gcfCache), { encoding: \"utf-8\" });\n}\n/**\n * 写入缓存数据\n * @param cacheFilePath\n * @param cacheData\n */\nexport function writeCacheData(cacheFilePath: string, cacheData: any) {\n    if (!cacheFilePath) {\n        Logger.log(`cacheFilePath is null`, \"error\");\n        return;\n    }\n    fs.writeFileSync(cacheFilePath, JSON.stringify(cacheData), { encoding: \"utf-8\" });\n}\n/**\n * 读取缓存数据\n * @param cacheFilePath\n */\nexport function getCacheData(cacheFilePath: string): any {\n    if (!cacheFilePath) {\n        Logger.log(`cacheFilePath is null`, \"error\");\n        return;\n    }\n    if (!fs.existsSync(cacheFilePath)) {\n        fs.ensureFileSync(cacheFilePath);\n        fs.writeFileSync(cacheFilePath, \"{}\", { encoding: \"utf-8\" });\n    }\n    const gcfCacheFile = fs.readFileSync(cacheFilePath, \"utf-8\");\n    const gcfCache = JSON.parse(gcfCacheFile);\n    return gcfCache;\n}\n/**\n * 获取文件md5 (同步)\n * @param filePath\n */\nexport function getFileMd5Sync(filePath: string, encoding?: BufferEncoding): string {\n    const file = fs.readFileSync(filePath, encoding);\n    var md5um = crypto.createHash(\"md5\");\n    md5um.update(file);\n    return md5um.digest(\"hex\");\n}\n/**\n * 获取文件md5 (异步)\n * @param filePath\n */\nexport function getFileMd5Async(filePath: string, cb: (md5Str: string) => void, encoding?: BufferEncoding) {\n    fs.readFile(filePath, encoding, (err, file) => {\n        var md5um = crypto.createHash(\"md5\");\n        md5um.update(file);\n        const md5Str = md5um.digest(\"hex\");\n        cb(md5Str);\n    });\n}\n/**\n * 获取文件md5\n * @param file 文件对象\n * @returns\n */\nexport function getFileMd5(file: any) {\n    const md5um = crypto.createHash(\"md5\");\n    md5um.update(file);\n    return md5um.digest(\"hex\");\n}\n/**\n * 获取文件 md5\n * @param filePath\n */\nexport async function getFileMd5ByPath(filePath: string) {\n    return getFileMd5Sync(filePath);\n}\n","import * as path from \"path\";\nimport * as fs from \"fs-extra\";\nimport { getCacheData, getFileMd5, writeCacheData, writeOrDeleteOutPutFiles } from \"./file-utils\";\nimport { Logger } from \"./loger\";\nimport { DefaultConvertHook } from \"./default-convert-hook\";\nimport fg from \"fast-glob\";\n\nconst defaultDir = \".excel2all\";\nconst cacheFileName = \".e2aprmc\";\nconst logFileName = \"excel2all.log\";\nlet startTime = 0;\nconst defaultPattern = [\"./**/*.xlsx\", \"./**/*.csv\"];\nconst needIgnorePattern = [\"!**/~$*.*\", \"!**/~.*.*\", \"!.git/**/*\", \"!.svn/**/*\"];\n/**\n * 转换\n * @param converConfig 解析配置\n */\nexport async function convert(converConfig: ITableConvertConfig) {\n    //开始时间\n    startTime = new Date().getTime();\n\n    if (!converConfig.projRoot) {\n        converConfig.projRoot = process.cwd();\n    }\n\n    Logger.init(converConfig);\n    const tableFileDir = converConfig.tableFileDir;\n    if (!tableFileDir) {\n        Logger.log(`配置表目录：tableFileDir为空`, \"error\");\n        return;\n    }\n    if (!fs.existsSync(tableFileDir)) {\n        Logger.log(`配置表文件夹不存在：${tableFileDir}`, \"error\");\n        return;\n    }\n\n    if (!converConfig.pattern) {\n        converConfig.pattern = defaultPattern;\n    }\n    converConfig.pattern = converConfig.pattern.concat(needIgnorePattern);\n\n    let convertHook = new DefaultConvertHook();\n    const context: IConvertContext = {\n        convertConfig: converConfig,\n        utils: {\n            fs: require(\"fs-extra\"),\n            xlsx: require(\"xlsx\")\n        }\n    };\n    const customConvertHook = converConfig.customConvertHook;\n    //开始\n    await new Promise<void>((res) => {\n        customConvertHook && customConvertHook.onStart\n            ? customConvertHook.onStart(context, res)\n            : convertHook.onStart(context, res);\n    });\n    const predoT1 = new Date().getTime();\n    getFileInfos(context);\n    const { parseResultMapCacheFilePath, changedFileInfos } = context;\n    const predoT2 = new Date().getTime();\n    Logger.systemLog(`[预处理数据时间:${predoT2 - predoT1}ms,${(predoT2 - predoT1) / 1000}]`);\n    await new Promise<void>((res) => {\n        customConvertHook && customConvertHook.onParseBefore\n            ? customConvertHook.onParseBefore(context, res)\n            : convertHook.onParseBefore(context, res);\n    });\n    Logger.systemLog(`[开始解析]:数量[${changedFileInfos.length}]`);\n\n    Logger.systemLog(`[解析]`);\n    if (changedFileInfos.length > 0) {\n        const t1 = new Date().getTime();\n        await new Promise<void>((res) => {\n            customConvertHook && customConvertHook.onParse\n                ? customConvertHook.onParse(context, res)\n                : convertHook.onParse(context, res);\n        });\n        const t2 = new Date().getTime();\n        Logger.systemLog(`[解析时间]:${t2 - t1}`);\n    }\n    onParseEnd(context, parseResultMapCacheFilePath, customConvertHook, convertHook);\n}\n\n/**\n * 解析结束\n * @param parseConfig\n * @param parseResultMapCacheFilePath\n * @param convertHook\n * @param fileInfos\n * @param deleteFileInfos\n * @param parseResultMap\n * @param logStr\n */\nasync function onParseEnd(\n    context: IConvertContext,\n    parseResultMapCacheFilePath: string,\n    customConvertHook: IConvertHook,\n    convertHook: IConvertHook,\n    logStr?: string\n) {\n    const convertConfig = context.convertConfig;\n    //写入解析缓存\n    if (convertConfig.useCache) {\n        writeCacheData(parseResultMapCacheFilePath, context.cacheData);\n    }\n\n    //解析结束，做导出处理\n    Logger.systemLog(`开始进行转换解析结果`);\n    const parseAfterT1 = new Date().getTime();\n    await new Promise<void>((res) => {\n        customConvertHook && customConvertHook.onParseAfter\n            ? customConvertHook.onParseAfter(context, res)\n            : convertHook.onParseAfter(context, res);\n    });\n    const parseAfterT2 = new Date().getTime();\n    Logger.systemLog(`转换解析结果结束:${parseAfterT2 - parseAfterT1}ms,${(parseAfterT2 - parseAfterT1) / 1000}s`);\n\n    if (context.outPutFileMap) {\n        const outputFileMap = context.outPutFileMap;\n        const outputFiles = Object.values(outputFileMap);\n        //写入和删除文件处理\n        Logger.systemLog(`开始写入文件:0/${outputFiles.length}`);\n\n        await new Promise<void>((res) => {\n            writeOrDeleteOutPutFiles(\n                outputFiles,\n                (filePath, total, now, isOk) => {\n                    Logger.log(`[写入文件] 进度:(${now}/${total}) 路径:${filePath}`);\n                },\n                () => {\n                    res();\n                }\n            );\n        });\n        Logger.systemLog(`写入结束~`);\n    } else {\n        Logger.systemLog(`没有可写入文件~`);\n    }\n\n    //写入日志文件\n\n    if (!logStr) {\n        logStr = Logger.logStr;\n    }\n    if (logStr.trim() !== \"\") {\n        let logFileDirPath = context.convertConfig.outputLogDirPath as string;\n        if (!logFileDirPath) logFileDirPath = defaultDir;\n        if (!path.isAbsolute(logFileDirPath)) {\n            logFileDirPath = path.join(context.convertConfig.projRoot, logFileDirPath);\n        }\n\n        const outputLogFileInfo: IOutPutFileInfo = {\n            filePath: path.join(logFileDirPath, logFileName),\n            data: logStr\n        };\n        writeOrDeleteOutPutFiles([outputLogFileInfo]);\n    }\n    //写入结束\n    customConvertHook && customConvertHook.onConvertEnd\n        ? customConvertHook.onConvertEnd(context)\n        : convertHook.onConvertEnd(context);\n    //结束时间\n    const endTime = new Date().getTime();\n    const useTime = endTime - startTime;\n    Logger.log(`导表总时间:[${useTime}ms],[${useTime / 1000}s]`);\n}\n/**\n * 测试文件匹配\n * @param convertConfig\n */\nexport function testFileMatch(convertConfig: ITableConvertConfig) {\n    if (!convertConfig.projRoot) {\n        convertConfig.projRoot = process.cwd();\n    }\n    const tableFileDir = convertConfig.tableFileDir;\n    if (!tableFileDir) {\n        Logger.log(`配置表目录：tableFileDir为空`, \"error\");\n        return;\n    }\n    if (!fs.existsSync(tableFileDir)) {\n        Logger.log(`配置表文件夹不存在：${tableFileDir}`, \"error\");\n        return;\n    }\n    if (!convertConfig.pattern) {\n        convertConfig.pattern = defaultPattern;\n    }\n    const context: IConvertContext = { convertConfig: convertConfig } as any;\n    let t1 = new Date().getTime();\n    getFileInfos(context);\n    let t2 = new Date().getTime();\n    console.log(`执行时间:${(t2 - t1) / 1000}s`);\n    if (convertConfig.useCache) {\n        console.log(`----【缓存模式】----`);\n    }\n    console.log(`------------------------------匹配到的文件---------------------`);\n    const filePaths = context.changedFileInfos.map((value) => {\n        return value.filePath;\n    });\n    console.log(filePaths);\n}\n/**\n * 使用fast-glob作为文件遍历\n * 获取需要解析的文件信息\n * @param context\n */\nfunction getFileInfos(context: IConvertContext) {\n    const converConfig = context.convertConfig;\n    let changedFileInfos: IFileInfo[] = [];\n    let deleteFileInfos: IFileInfo[] = [];\n    const tableFileDir = converConfig.tableFileDir;\n    const getFileInfo = (filePath: string, isDelete?: boolean) => {\n        const filePathParse = path.parse(filePath);\n\n        let fileData = !isDelete ? fs.readFileSync(filePath) : undefined;\n\n        const fileInfo: IFileInfo = {\n            filePath: filePath,\n            fileName: filePathParse.name,\n            fileExtName: filePathParse.ext,\n            isDelete: isDelete,\n            fileData: fileData\n        };\n        return fileInfo;\n    };\n    const matchPattern = converConfig.pattern;\n\n    const filePaths: string[] = fg.sync(matchPattern, {\n        absolute: true,\n        onlyFiles: true,\n        caseSensitiveMatch: false,\n        cwd: tableFileDir\n    });\n    let parseResultMap: TableParseResultMap = {};\n    let cacheData: ITableConvertCacheData;\n    //缓存处理\n    let cacheFileDirPath: string = converConfig.cacheFileDirPath;\n    let parseResultMapCacheFilePath: string;\n    let fileInfo: IFileInfo;\n    if (!converConfig.useCache) {\n        for (let i = 0; i < filePaths.length; i++) {\n            fileInfo = getFileInfo(filePaths[i]);\n            changedFileInfos.push(fileInfo);\n        }\n    } else {\n        let t1 = new Date().getTime();\n        if (!cacheFileDirPath) cacheFileDirPath = defaultDir;\n        if (!path.isAbsolute(cacheFileDirPath)) {\n            cacheFileDirPath = path.join(converConfig.projRoot, cacheFileDirPath);\n        }\n        parseResultMapCacheFilePath = path.join(cacheFileDirPath, cacheFileName);\n        Logger.systemLog(`读取缓存数据`);\n\n        cacheData = getCacheData(parseResultMapCacheFilePath);\n        console.log(__dirname);\n        const packageJson = getCacheData(path.join(__dirname, \"../../../package.json\"));\n        if (!cacheData.version || cacheData.version !== packageJson.version) {\n            Logger.systemLog(\n                `工具版本不一致，缓存失效 => cacheVersion:${cacheData.version},toolVersion:${packageJson.version}`\n            );\n\n            parseResultMap = {};\n        } else {\n            parseResultMap = cacheData.parseResultMap;\n        }\n        if (!parseResultMap) {\n            parseResultMap = {};\n        }\n        cacheData.parseResultMap = parseResultMap;\n        cacheData.version = packageJson.version;\n\n        Logger.systemLog(`开始缓存处理...`);\n        const oldFilePaths = Object.keys(parseResultMap);\n        let oldFilePathIndex: number;\n        let parseResult: ITableParseResult;\n        let filePath: string;\n        for (let i = 0; i < filePaths.length; i++) {\n            filePath = filePaths[i];\n            fileInfo = getFileInfo(filePath);\n            const fileData = fileInfo.fileData;\n            parseResult = parseResultMap[filePath];\n            var md5str = getFileMd5(fileData);\n            if (!parseResult || (parseResult && (parseResult.hasError || parseResult.md5hash !== md5str))) {\n                parseResult = {\n                    filePath: filePath\n                };\n                parseResultMap[filePath] = parseResult;\n                parseResult.md5hash = md5str;\n                changedFileInfos.push(fileInfo);\n            }\n            //判断文件是否还存在\n            oldFilePathIndex = oldFilePaths.indexOf(filePath);\n            if (oldFilePathIndex > -1) {\n                const endFilePath = oldFilePaths[oldFilePaths.length - 1];\n                oldFilePaths[oldFilePathIndex] = endFilePath;\n                oldFilePaths.pop();\n            }\n        }\n        //删除旧文件\n        for (let i = 0; i < oldFilePaths.length; i++) {\n            delete parseResultMap[oldFilePaths[i]];\n            let deleteFileInfo = getFileInfo(oldFilePaths[i], true);\n            deleteFileInfos.push(deleteFileInfo);\n        }\n\n        let t2 = new Date().getTime();\n        Logger.systemLog(`缓存处理时间:${t2 - t1}ms,${(t2 - t1) / 1000}s`);\n    }\n    context.deleteFileInfos = deleteFileInfos;\n    context.changedFileInfos = changedFileInfos;\n    context.parseResultMap = parseResultMap;\n    context.cacheData = cacheData;\n    context.parseResultMapCacheFilePath = parseResultMapCacheFilePath;\n}\n"],"names":[],"mappings":"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"}